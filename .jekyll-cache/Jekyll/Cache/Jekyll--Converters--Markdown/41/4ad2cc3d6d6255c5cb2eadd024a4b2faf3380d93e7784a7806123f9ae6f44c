I"k<ul id="markdown-toc">
  <li><a href="#参考" id="markdown-toc-参考">参考</a></li>
  <li><a href="#fortran自身" id="markdown-toc-fortran自身">Fortran自身</a></li>
  <li><a href="#数学库间关系" id="markdown-toc-数学库间关系">数学库间关系</a></li>
  <li><a href="#线性程序库" id="markdown-toc-线性程序库">线性程序库</a>    <ul>
      <li><a href="#blas-basic-linear-algebra-subprograms-基本线性代数子程序" id="markdown-toc-blas-basic-linear-algebra-subprograms-基本线性代数子程序">BLAS (Basic Linear Algebra Subprograms) 基本线性代数子程序</a>        <ul>
          <li><a href="#编译连接" id="markdown-toc-编译连接">编译连接</a></li>
          <li><a href="#调用直接使用" id="markdown-toc-调用直接使用">调用：直接使用</a></li>
          <li><a href="#函数命令" id="markdown-toc-函数命令">函数命令</a></li>
          <li><a href="#函数名xyyzzz说明" id="markdown-toc-函数名xyyzzz说明">函数名XYYZZZ说明</a></li>
        </ul>
      </li>
      <li><a href="#lapacklinear-algebra-package-lapack---线性代数包" id="markdown-toc-lapacklinear-algebra-package-lapack---线性代数包">Lapack ( Linear Algebra PACKage) Lapack   线性代数包</a></li>
      <li><a href="#scalapackscalable-linear-algebra-package-可扩展的线性代数包并行的lapack" id="markdown-toc-scalapackscalable-linear-algebra-package-可扩展的线性代数包并行的lapack">ScaLapack ( Scalable Linear Algebra PACKage) 可扩展的线性代数包（并行的Lapack）</a>        <ul>
          <li><a href="#编译连接-1" id="markdown-toc-编译连接-1">编译连接</a></li>
          <li><a href="#调用过程" id="markdown-toc-调用过程">调用过程</a></li>
          <li><a href="#示例程序-1从文件中读取数据并分发计算2019-04-06可能编程不规范" id="markdown-toc-示例程序-1从文件中读取数据并分发计算2019-04-06可能编程不规范">示例程序 1.从文件中读取数据并分发计算(2019-04-06，可能编程不规范)</a></li>
          <li><a href="#示例程序-2-将已有矩阵进行重新分发2019-04-30" id="markdown-toc-示例程序-2-将已有矩阵进行重新分发2019-04-30">示例程序 2. 将已有矩阵进行重新分发(2019-04-30)</a></li>
          <li><a href="#数据读写" id="markdown-toc-数据读写">数据读写</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#blaslapackscalapack编译" id="markdown-toc-blaslapackscalapack编译">BLAS，Lapack，ScaLapack编译</a>    <ul>
      <li><a href="#编译报错原因" id="markdown-toc-编译报错原因">编译报错原因</a>        <ul>
          <li><a href="#库和编译器不匹配" id="markdown-toc-库和编译器不匹配">库和编译器不匹配</a></li>
          <li><a href="#库的链接顺序有要求" id="markdown-toc-库的链接顺序有要求">库的链接顺序有要求</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#fft" id="markdown-toc-fft">FFT</a>    <ul>
      <li><a href="#fftw3" id="markdown-toc-fftw3">FFTW3</a></li>
    </ul>
  </li>
</ul>

<p>该文不完全，边学边总结<br /></p>

<h2 id="参考">参考</h2>
<p><a href="https://www.cnblogs.com/djcsch2001/articles/2309440.html">Fortran 入门——基本矩阵运算</a></p>

<p><a href="https://blog.csdn.net/G_Spider/article/details/6054990">BLAS库学习</a></p>

<p><a href="https://www.jianshu.com/p/8e58c28628a0">ScaLapack 简介</a></p>

<h2 id="fortran自身">Fortran自身</h2>

<p>矩阵可以直接相加减，与MATLAB中的矩阵点乘点除</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C=A+-*/B 等价于 C(i,j)=A(i,j)+-*/B(i,j)
A+-*/c 等价于A(i,j)+-*/c
</code></pre></div></div>
<p>矩阵相乘</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>matmul(A,B)
</code></pre></div></div>
<p>矩阵 转置</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>transpose(A)
</code></pre></div></div>

<h2 id="数学库间关系">数学库间关系</h2>
<p>数学库说明<a href="/web/file/2019/并行程序开发工具与高性能程序库_张林波_并行计算导论.pdf">并行程序开发工具与高性能程序库</a></p>

<blockquote>
  <ul>
    <li>FFT（快速傅立叶变换）</li>
    <li>BLAS（基础线性代数函数库）</li>
    <li>Lapack（线性代数Package）、</li>
    <li>ScaLapack（高扩展的Lapack，主要用于分布式内存体系结构，也就是Cluster结构的并行化的Lapack）</li>
  </ul>
</blockquote>

<p>线性代数程序库
<img src="/uploads/2019/04/scalapack.png" alt="" /></p>
<blockquote>
  <p>其中</p>

  <ul>
    <li>BLAS （Basic Linear Algebra Subprograms），包含很多常用的线性代数运算子程序，如向量点积，矩阵和向量乘积，矩阵和矩阵乘积等；<br /></li>
    <li>BLACS （Basic Linear Algebra Communication Subprograms），是一个专门为线性代数运算而设计的消息传递库；<br /></li>
    <li>Lapack （Linear Algebra PACKage），包含一系列的程序，可以求解如线性方程组，最小二乘问题，本征值问题，奇异值问题等，通过调用 BLAS 完成大部分工作以获得高的运算性能；<br /></li>
    <li>PBLAS （Parallel BLAS），为 ScaLapack 而设计的一个分布式内存 BLAS 库</li>
  </ul>
</blockquote>

<h2 id="线性程序库">线性程序库</h2>
<h3 id="blas-basic-linear-algebra-subprograms-基本线性代数子程序">BLAS (Basic Linear Algebra Subprograms) 基本线性代数子程序</h3>
<h4 id="编译连接">编译连接</h4>
<p>netlib数学库编译</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gfortran  -g -O2 -ffree-line-length-none    -o mytest  mytest.f90 -L/home/cndaqiang/soft/scalapack/lib -lrefblas 
</code></pre></div></div>
<p>使用ifort和mkl时，参考<a href="https://software.intel.com/en-us/articles/intel-mkl-link-line-advisor/">自助调用</a><br />
动态链接</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ifort mytest.f90  ${MKLROOT}/lib/intel64/libmkl_blas95_ilp64.a -L${MKLROOT}/lib/intel64 -lmkl_intel_ilp64 -lmkl_sequential -lmkl_core -lpthread -lm -ldl
</code></pre></div></div>
<p>静态链接</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ifort mytest.f90  ${MKLROOT}/lib/intel64/libmkl_blas95_ilp64.a -Wl,--start-group ${MKLROOT}/lib/intel64/libmkl_intel_ilp64.a ${MKLROOT}/lib/intel64/libmkl_sequential.a ${MKLROOT}/lib/intel64/libmkl_core.a -Wl,--end-group -lpthread -lm -ldl
</code></pre></div></div>

<h4 id="调用直接使用">调用：直接使用</h4>
<p>不用任何多余操作，直接调用函数，如计算矩阵积的函数</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>call SGEMM("N","N",3,3,3,1.0,A,3,B,3,0,C,3)
</code></pre></div></div>

<h4 id="函数命令">函数命令</h4>

<p>程序分为3个level</p>
<ul>
  <li>Level 1
<br />Vector operations, e.g. y = /alpha x + y  向量操作</li>
  <li>Level 2
<br />Matrix-vector operations, e.g. y = /alpha A x + /beta y  矩阵(M)与向量(V)操作</li>
  <li>Level 3
<br />Matrix-matrix operations, e.g. C = /alpha A B + C    矩阵(M)与矩阵(M)的操作</li>
</ul>

<h4 id="函数名xyyzzz说明">函数名XYYZZZ说明</h4>
<ul>
  <li>X:数据类型
<br /><code class="highlighter-rouge">S</code> REAL，单精度实数
<br /><code class="highlighter-rouge">D</code> DOUBLE PRECISION，双精度实数
<br /><code class="highlighter-rouge">C</code> COMPLEX，单精度复数
<br /><code class="highlighter-rouge">Z</code> COMPLEX*16 或 DOUBLE COMPLEX</li>
  <li>
    <p>YY:数组的类型
<br /><code class="highlighter-rouge">GE</code> 一般矩阵
<br /> <strong><code class="highlighter-rouge">SY</code> symmetric，对称阵不定矩阵
<br /> **<code class="highlighter-rouge">PO</code> symmetric postive-define 对称正定矩阵(s.p.d)</strong> A=A^T,任意x!=0有 x^T<em>A</em>x&gt;0
<br />  <strong>__</strong> 如重叠矩阵:x^TSx=&lt;x|x&gt; &gt;0
<br /><code class="highlighter-rouge">BD</code> bidiagonal，双对角矩阵
<br /><code class="highlighter-rouge">DI</code> diagonal，对角矩阵
<br /><code class="highlighter-rouge">GB</code> general band，一般带状矩阵
<br /></p>
  </li>
  <li>….</li>
  <li>等等</li>
  <li>ZZ[Z]:处理计算方法
<br /> <code class="highlighter-rouge">MM</code> 矩阵乘矩作
<br /> <code class="highlighter-rouge">SV</code> 矩阵乘向量
<br /> 等等</li>
</ul>

<p><a href="http://www.netlib.org/blas/">BLAS (Basic Linear Algebra Subprograms)</a>对各个函数进行了详细的说明，如<code class="highlighter-rouge">SGEMM</code>单精度普通矩阵与矩阵的乘法</p>

<div class="language-fortran highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">subroutine</span><span class="w"> 	</span><span class="n">sgemm</span><span class="w"> </span><span class="p">(</span><span class="n">TRANSA</span><span class="p">,</span><span class="w"> </span><span class="n">TRANSB</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">ALPHA</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">LDA</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">LDB</span><span class="p">,</span><span class="w"> </span><span class="n">BETA</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">LDC</span><span class="p">)</span><span class="w">
</span><span class="c1">!说明：</span><span class="w">
 </span><span class="n">C</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="n">alpha</span><span class="o">*</span><span class="n">op</span><span class="p">(</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">)</span><span class="o">*</span><span class="n">op</span><span class="p">(</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">beta</span><span class="o">*</span><span class="n">C</span><span class="w">
 </span><span class="n">A</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">K</span><span class="p">)</span><span class="w">
 </span><span class="n">B</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="w">
 </span><span class="n">TRANSA</span><span class="p">:</span><span class="n">op</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="w">
 	</span><span class="n">TRANSA</span><span class="o">=</span><span class="s2">"N"</span><span class="p">,</span><span class="w"> </span><span class="n">op</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">=</span><span class="n">A</span><span class="w">
 	</span><span class="n">TRANSA</span><span class="o">=</span><span class="s2">"T"</span><span class="p">,</span><span class="w"> </span><span class="n">op</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">=</span><span class="n">A</span><span class="o">**</span><span class="n">T</span><span class="w"> </span><span class="err">转置</span><span class="w">
 	</span><span class="n">TRANSA</span><span class="o">=</span><span class="s2">"C"</span><span class="p">,</span><span class="w"> </span><span class="n">op</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">=</span><span class="n">A</span><span class="o">**</span><span class="n">T</span><span class="w">
 </span><span class="n">TRANSB</span><span class="p">:</span><span class="n">op</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="w">
 	</span><span class="err">同</span><span class="n">TRANSA</span><span class="w">
 </span><span class="n">ALPHA</span><span class="p">:</span><span class="n">alpha</span><span class="w">
 </span><span class="n">BETA</span><span class="p">:</span><span class="n">beta</span><span class="w">
 </span><span class="n">LDA</span><span class="p">:</span><span class="n">A</span><span class="err">的列数</span><span class="w">
 </span><span class="n">LBB</span><span class="p">,</span><span class="n">LDC</span><span class="err">同</span><span class="n">A</span><span class="w">
</span></code></pre></div></div>

<h3 id="lapacklinear-algebra-package-lapack---线性代数包">Lapack ( Linear Algebra PACKage) Lapack   线性代数包</h3>
<p>同blas</p>

<h3 id="scalapackscalable-linear-algebra-package-可扩展的线性代数包并行的lapack">ScaLapack ( Scalable Linear Algebra PACKage) 可扩展的线性代数包（并行的Lapack）</h3>
<p>对于与 Lapack 相对应的 ScaLapack 程序的名称，<br />
只是简单地在 Lapack 名称前面加一个 P,<code class="highlighter-rouge"> PvYYZZZ </code>
说明<a href="http://www.netlib.org/scalapack/pblas_qref.html">PBLAS Home Page</a>，下面函数名<code class="highlighter-rouge">PvYYZZZ</code>中，v换成<code class="highlighter-rouge">S、D、C、Z</code></p>

<h4 id="编译连接-1">编译连接</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mpif90  -g -O2 -ffree-line-length-none    -o test  mytest.f90 m_mpi_my.o  /home/cndaqiang/soft/scalapack/lib/libscalapack.a  /home/cndaqiang/soft/scalapack/lib/libtmg.a  /home/cndaqiang/soft/scalapack/lib/libreflapack.a /home/cndaqiang/soft/scalapack/lib/librefblas.a
</code></pre></div></div>

<h4 id="调用过程">调用过程</h4>
<p>教程<a href="http://www.netlib.org/scalapack/tutorial/">ScaLapack Tutorial</a></p>

<ol>
  <li>Initialize the process grid 初始化处理器网格</li>
  <li>Distribute the matrix on the process grid 分布矩阵</li>
  <li>Call ScaLapack routine 执行计算
<br /><strong>注意错误，若程序要求输入整数，单精度，双精度，一定要给对类型才能计算</strong>
<br /> <strong><code class="highlighter-rouge">1.0</code>是单精度，<code class="highlighter-rouge">1.0_8</code>是双精度</strong></li>
  <li>Release the process grid 释放网格</li>
</ol>

<h4 id="示例程序-1从文件中读取数据并分发计算2019-04-06可能编程不规范">示例程序 1.从文件中读取数据并分发计算(2019-04-06，可能编程不规范)</h4>

<p>程序图解<img src="/uploads/2019/04/scalapackrun.jpg" alt="" /></p>
<div class="language-fortran highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">program</span><span class="w"> </span><span class="n">mytest</span><span class="w">
        </span><span class="k">use</span><span class="w"> </span><span class="n">m_mpi_my</span><span class="w">
        </span><span class="k">implicit</span><span class="w"> </span><span class="k">none</span><span class="w">
        
        </span><span class="kt">INTEGER</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="w">

        </span><span class="kt">INTEGER</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">ICTXT</span><span class="w">
        </span><span class="kt">INTEGER</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">NPROW</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">NPCOL</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">IRREAD</span><span class="p">,</span><span class="n">ICREAD</span><span class="p">,</span><span class="n">MYROW</span><span class="p">,</span><span class="n">MYCOL</span><span class="w">
        
        </span><span class="kt">INTEGER</span><span class="p">,</span><span class="k">PARAMETER</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">DLEN_</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span><span class="n">MAXLLDA</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">MAXLLDB</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span><span class="n">MAXLLDC</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">MAXLLDE</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">MAXLOCC</span><span class="o">=</span><span class="mi">3</span><span class="w">
        </span><span class="kt">INTEGER</span><span class="p">,</span><span class="k">PARAMETER</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">SP</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span><span class="n">dp</span><span class="o">=</span><span class="mi">8</span><span class="w">
        
        </span><span class="kt">REAL</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">B</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">E</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="w">
        
        </span><span class="kt">INTEGER</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">DESCA</span><span class="p">(</span><span class="n">DLEN_</span><span class="p">),</span><span class="n">DESCB</span><span class="p">(</span><span class="n">DLEN_</span><span class="p">),</span><span class="n">DESCC</span><span class="p">(</span><span class="n">DLEN_</span><span class="p">)</span><span class="w">
        </span><span class="kt">INTEGER</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">INFO</span><span class="p">,</span><span class="w"> </span><span class="n">ICSRC</span><span class="p">,</span><span class="n">IRSRC</span><span class="p">,</span><span class="w"> </span><span class="n">LLD</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">MB</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">NB</span><span class="w">
        </span><span class="kt">REAL</span><span class="p">(</span><span class="n">dp</span><span class="p">),</span><span class="k">allocatable</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">WORK</span><span class="p">(:)</span><span class="w">

        </span><span class="k">call</span><span class="w"> </span><span class="n">mpi_start</span><span class="p">()</span><span class="w">
 
</span><span class="c1">!=======1.初始化</span><span class="w">
    </span><span class="c1">!1.1初始化处理器网格化为NPROW*NPCOL</span><span class="w">
        </span><span class="c1">!如果运行时 np &gt; NPROW*NPCOL, 多余核的MYROW会从负数开始，可用于检测是否被分配</span><span class="w">
        </span><span class="c1">!ICTXT BLACS句柄,并行计算空间索引</span><span class="w">
        </span><span class="k">call</span><span class="w"> </span><span class="n">SL_INIT</span><span class="p">(</span><span class="n">ICTXT</span><span class="p">,</span><span class="n">NPROW</span><span class="p">,</span><span class="n">NPCOL</span><span class="p">)</span><span class="w">
        </span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="mf">123.0_8</span><span class="p">,</span><span class="mf">456.0</span><span class="w"> 
    </span><span class="c1">!1.2 获得初始化信息,当前node所在网格的位置(MYROW,MYCOL)</span><span class="w">
        </span><span class="c1">!CALL BLACS_GET( -1, 0, ICTXT )  !获得默认上下文 ICTX</span><span class="w">
        </span><span class="c1">!CALL BLACS_GRIDINIT( ICTXT, 'Row-major', NPROW, NPCOL) !BLACS_GRIDINIT 定义进程网格，'Row-major' 说明网格是按照行优先的顺序排列的；</span><span class="w">
        </span><span class="c1">!可以直接使用call BLACS_GRIFINFO</span><span class="w">
        </span><span class="c1">!BLACS_GRIDINFO 获得本进程在进程网格中的位置信息  </span><span class="w">
        </span><span class="k">call</span><span class="w"> </span><span class="n">BLACS_GRIDINFO</span><span class="p">(</span><span class="n">ICTXT</span><span class="p">,</span><span class="n">NPROW</span><span class="p">,</span><span class="n">NPCOL</span><span class="p">,</span><span class="n">MYROW</span><span class="p">,</span><span class="n">MYCOL</span><span class="p">)</span><span class="w">
        </span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="s2">"node is :"</span><span class="p">,</span><span class="n">node</span><span class="p">,</span><span class="s2">"MYROW and MYCOL :"</span><span class="p">,</span><span class="n">MYROW</span><span class="p">,</span><span class="n">MYCOL</span><span class="w"> 
        </span><span class="k">call</span><span class="w"> </span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">
        </span><span class="k">call</span><span class="w"> </span><span class="n">MPI_BARRIER</span><span class="p">(</span><span class="n">my_COMM</span><span class="p">,</span><span class="n">mpi_ierr</span><span class="p">)</span><span class="w">
 
        
</span><span class="c1">!=======2.初始化矩阵:分布到进程,分配信息存储到DESC中</span><span class="w">
     </span><span class="c1">!2.1 创建分配规则</span><span class="w">
        </span><span class="n">M</span><span class="o">=</span><span class="mi">8</span><span class="w">  </span><span class="c1">!待分配矩阵的总行</span><span class="w">
        </span><span class="n">N</span><span class="o">=</span><span class="mi">8</span><span class="w">  </span><span class="c1">!            列</span><span class="w">
        </span><span class="n">MB</span><span class="o">=</span><span class="mi">4</span><span class="w"> </span><span class="c1">!M block 分块矩阵的行为MB</span><span class="w">
        </span><span class="n">NB</span><span class="o">=</span><span class="mi">4</span><span class="w"> </span><span class="c1">!N block         列  NB</span><span class="w">
        </span><span class="n">LLD</span><span class="o">=</span><span class="mi">4</span><span class="w"> </span><span class="c1">!必须==局域矩阵的LD(local leading dimension)</span><span class="w">
              </span><span class="c1">! 局域矩阵的最大行数  &gt;= 分到每个节点总矩阵的最大值LDD,大约是(n-1)*MB~n*MB</span><span class="w">
              </span><span class="c1">! LLD &gt;= MAX(1,LOCr(M)). LOCr(local cor 局域矩阵的行</span><span class="w">
              </span><span class="c1">! LLD 决定了读取了数据之后如何存储到本地矩阵中去</span><span class="w">
        </span><span class="n">IRSRC</span><span class="o">=</span><span class="n">master_node</span><span class="w"> </span><span class="c1">!矩阵被分开后，获得第一个行分块的node</span><span class="w">
        </span><span class="n">ICSRC</span><span class="o">=</span><span class="n">master_node</span><span class="w"> </span><span class="c1">!                    列</span><span class="w">
        </span><span class="c1">!INFO 成功i执行返回0</span><span class="w">
        </span><span class="c1">!执行错误返回&lt; 0</span><span class="w">
        </span><span class="c1">!错误代码核解释在descinit.f中有，在线搜索INFO:http://www.netlib.org/scalapack/explore-html/dd/d22/descinit_8f_source.html</span><span class="w">
        
        </span><span class="c1">!DESC</span><span class="w">
        </span><span class="c1">!创建分配规则(数组描述符)DESC, call DESCINIT()</span><span class="w">
        </span><span class="c1">!每一个被分配的矩阵都有一个描述符DESC，是之后计算的必须因素</span><span class="w">
        </span><span class="c1">!DESC源文件里面解释了所有的东西，静下心来读</span><span class="w">
        </span><span class="c1">!DESC 共9个元素 INTEGER :: DESC(9), 每个维度的意思为</span><span class="w">
        </span><span class="c1">!DTYPE_ = 1,CTXT_ = 2, M_ = 3, N_ = 4, MB_ = 5, NB_ = 6,RSRC_ = 7, CSRC_ = 8, LLD_ = 9</span><span class="w">
        </span><span class="c1">!"_" 代表 of the global array</span><span class="w">
        </span><span class="k">call</span><span class="w"> </span><span class="n">DESCINIT</span><span class="p">(</span><span class="n">DESCA</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">MB</span><span class="p">,</span><span class="n">NB</span><span class="p">,</span><span class="n">IRSRC</span><span class="p">,</span><span class="n">ICSRC</span><span class="p">,</span><span class="n">ICTXT</span><span class="p">,</span><span class="n">LLD</span><span class="p">,</span><span class="n">INFO</span><span class="p">)</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="ow">.eq.</span><span class="w"> </span><span class="n">master_node</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w">
                </span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="s2">"OK 0?"</span><span class="p">,</span><span class="w"> </span><span class="n">INFO</span><span class="w">
                </span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="s2">"DTYPE_ = 1,CTXT_ = 2, M_ = 3, N_ = 4, MB_ = 5, NB_ = 6,RSRC_ = 7, CSRC_ = 8, LLD_ = 9"</span><span class="w">
                </span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">DESCA</span><span class="w">
        </span><span class="k">endif</span><span class="w">
        </span><span class="k">call</span><span class="w"> </span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">
     </span><span class="c1">!2.2 分配矩阵到节点网格</span><span class="w">

        </span><span class="c1">!A 分配后存储在各节点：局域矩阵名</span><span class="w">
        </span><span class="c1">!A 的维度定义与DESCINIT()有对应关系</span><span class="w">
        </span><span class="n">IRREAD</span><span class="o">=</span><span class="mi">0</span><span class="w"> </span><span class="c1">!读取数据的进程在处理器网格中的位置(IRREAD, ICREAD)</span><span class="w">
        </span><span class="n">ICREAD</span><span class="o">=</span><span class="mi">0</span><span class="w">  </span><span class="c1">!读取数据的进程在处理器网格中的位置(IRREAD, ICREAD)</span><span class="w">
        </span><span class="k">allocate</span><span class="p">(</span><span class="n">WORK</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span><span class="w">  </span><span class="c1">!一次读取数据的长度，要长一些，WORK维数 &gt;= MB</span><span class="w">
        </span><span class="c1">!http://www.netlib.org/scalapack/explore-html/d5/d47/pdlaread_8f_source.html</span><span class="w">
        </span><span class="c1">!源码中DO K = 1, IB ; READ( NIN, FMT = * ) WORK( K )</span><span class="w">
        </span><span class="k">call</span><span class="w"> </span><span class="n">PdLAREAD</span><span class="p">(</span><span class="s2">"A.data"</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">DESCA</span><span class="p">,</span><span class="n">IRREAD</span><span class="p">,</span><span class="n">ICREAD</span><span class="p">,</span><span class="n">WORK</span><span class="p">)</span><span class="w">
        </span><span class="c1">!数据文件A.data内容:</span><span class="w">
        	</span><span class="err">！第一行</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="n">N</span><span class="w">
        	</span><span class="c1">! 第i(i&gt;1)行 A(i)，就一个数据</span><span class="w">
        
        </span><span class="c1">!查看分布结果</span><span class="w">
        </span><span class="k">Do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="mi">-1</span><span class="w">
           </span><span class="k">call</span><span class="w"> </span><span class="n">MPI_BARRIER</span><span class="p">(</span><span class="n">my_COMM</span><span class="p">,</span><span class="n">mpi_ierr</span><span class="p">)</span><span class="w">
           </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="w"> </span><span class="ow">.eq.</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w"> 
                </span><span class="k">Do</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="nb">size</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="nb">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="w">
                        </span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="s2">"A"</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">,</span><span class="n">A</span><span class="p">(</span><span class="n">j</span><span class="p">,:)</span><span class="w">
                </span><span class="k">EndDO</span><span class="w">
           </span><span class="k">Endif</span><span class="w">
        </span><span class="k">EndDO</span><span class="w">
       
        </span><span class="k">call</span><span class="w"> </span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">
 
       </span><span class="c1">!分布B，解释同上</span><span class="w">
       </span><span class="c1">! 注释DESCINIT(DESCA,M,N,MB,NB,IRSRC,ICSRC,ICTXT,LLD,INFO)</span><span class="w">
        </span><span class="k">call</span><span class="w"> </span><span class="n">DESCINIT</span><span class="p">(</span><span class="n">DESCB</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">IRSRC</span><span class="p">,</span><span class="n">ICSRC</span><span class="p">,</span><span class="n">ICTXT</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">INFO</span><span class="p">)</span><span class="w">
        </span><span class="c1">!write(*,*) "node",node, INFO</span><span class="w">
        </span><span class="k">call</span><span class="w"> </span><span class="n">PdLAREAD</span><span class="p">(</span><span class="s2">"B.data"</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">DESCB</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">WORK</span><span class="p">)</span><span class="w">
       </span><span class="c1">!分布C</span><span class="w">
        </span><span class="k">call</span><span class="w"> </span><span class="n">DESCINIT</span><span class="p">(</span><span class="n">DESCC</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">IRSRC</span><span class="p">,</span><span class="n">ICSRC</span><span class="p">,</span><span class="n">ICTXT</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">INFO</span><span class="p">)</span><span class="w">
        </span><span class="c1">!call PDLAREAD("B.data",C,DESCC,0,0,WORK)</span><span class="w">
        </span><span class="c1">!if( (node .eq. 0 ) .or. (node .eq. 3)) </span><span class="w">
        </span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w">  </span><span class="s2">"B"</span><span class="p">,</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="w">
        </span><span class="k">call</span><span class="w"> </span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">

</span><span class="c1">!=======3. 计算操作</span><span class="w">
        
       </span><span class="c1">!注释PvGEMM( TRANSA, TRANSB, M, N, K, ALPHA, A, IA, JA, DESCA, B, IB, JB,DESCB, BETA, C, IC, JC, DESCC ) </span><span class="w">
        </span><span class="k">call</span><span class="w"> </span><span class="n">Pdgemm</span><span class="p">(</span><span class="s2">"N"</span><span class="p">,</span><span class="s2">"N"</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mf">1.0_dp</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">DESCA</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">DESCB</span><span class="p">,</span><span class="mf">0.0_dp</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">DESCC</span><span class="p">)</span><span class="w">
        </span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="s2">"C"</span><span class="p">,</span><span class="n">node</span><span class="p">,</span><span class="n">C</span><span class="w">
        </span><span class="c1">!if( (node .eq. 0 ) .or. (node .eq. 3)) write(*,*) "C in node",node,"is", C</span><span class="w">
</span><span class="c1">!=======4. 释放进程网络</span><span class="w">
        </span><span class="k">CALL</span><span class="w"> </span><span class="n">BLACS_GRIDEXIT</span><span class="p">(</span><span class="w"> </span><span class="n">ICTXT</span><span class="w"> </span><span class="p">)</span><span class="w">
        </span><span class="c1">!Exit the BLACS</span><span class="w">
        </span><span class="c1">!CALL BLACS_EXIT( 0 ) 这个程序里包含MPI_FINALIZE,先不使用此函数退出</span><span class="w">
        </span><span class="k">deallocate</span><span class="p">(</span><span class="n">WORK</span><span class="p">)</span><span class="w">
        </span><span class="k">call</span><span class="w"> </span><span class="n">mpi_end</span><span class="p">()</span><span class="w">
</span><span class="k">End</span><span class="w"> </span><span class="k">program</span><span class="w">
</span></code></pre></div></div>

<p>运行结果</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[cndaqiang@managernode matlib]$ !mp
mpirun -np 4 ./test 
   123.00000000000000        456.000000    
 node is :           0 MYROW and MYCOL :           0           0
   123.00000000000000        456.000000    
 node is :           1 MYROW and MYCOL :           0           1
   123.00000000000000        456.000000    
 node is :           2 MYROW and MYCOL :           1           0
   123.00000000000000        456.000000    
 node is :           3 MYROW and MYCOL :           1           1
 OK 0?           0
 DTYPE_ = 1,CTXT_ = 2, M_ = 3, N_ = 4, MB_ = 5, NB_ = 6,RSRC_ = 7, CSRC_ = 8, LLD_ = 9
           1           0           8           8           4           4           0           0           8
 A           0   1.0000000000000000        9.0000000000000000        17.000000000000000        25.000000000000000     
 A           0   2.0000000000000000        10.000000000000000        18.000000000000000        26.000000000000000     
 A           0   3.0000000000000000        11.000000000000000        19.000000000000000        27.000000000000000     
 A           0   4.0000000000000000        12.000000000000000        20.000000000000000        28.000000000000000     
 A           0   0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000     
 A           0   0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000     
 A           0   0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000     
 A           0   0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000     
 A           1   33.000000000000000        41.000000000000000        49.000000000000000        57.000000000000000     
 A           1   34.000000000000000        42.000000000000000        50.000000000000000        58.000000000000000     
 A           1   35.000000000000000        43.000000000000000        51.000000000000000        59.000000000000000     
 A           1   36.000000000000000        44.000000000000000        52.000000000000000        60.000000000000000     
 A           1   0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000     
 A           1   0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000     
 A           1   0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000     
 A           1   0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000     
 A           2   5.0000000000000000        13.000000000000000        21.000000000000000        29.000000000000000     
 A           2   6.0000000000000000        14.000000000000000        22.000000000000000        30.000000000000000     
 A           2   7.0000000000000000        15.000000000000000        23.000000000000000        31.000000000000000     
 A           2   8.0000000000000000        16.000000000000000        24.000000000000000        32.000000000000000     
 A           2   0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000     
 A           2   0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000     
 A           2   0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000     
 A           2   0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000     
 A           3   37.000000000000000        45.000000000000000        53.000000000000000        61.000000000000000     
 A           3   38.000000000000000        46.000000000000000        54.000000000000000        62.000000000000000     
 A           3   39.000000000000000        47.000000000000000        55.000000000000000        63.000000000000000     
 A           3   40.000000000000000        48.000000000000000        56.000000000000000        64.000000000000000     
 A           3   0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000     
 A           3   0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000     
 A           3   0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000     
 A           3   0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000     
 B           2   2.0000000000000000        0.0000000000000000        4.0000000000000000        0.0000000000000000        10.000000000000000        0.0000000000000000        12.000000000000000        0.0000000000000000     
 B           0   1.0000000000000000        0.0000000000000000        3.0000000000000000        0.0000000000000000        9.0000000000000000        0.0000000000000000        11.000000000000000        0.0000000000000000     
 B           1   5.0000000000000000        0.0000000000000000        7.0000000000000000        0.0000000000000000        13.000000000000000        0.0000000000000000        15.000000000000000        0.0000000000000000     
 B           3   6.0000000000000000        0.0000000000000000        8.0000000000000000        0.0000000000000000        14.000000000000000        0.0000000000000000        16.000000000000000        0.0000000000000000     
 C           2   22.000000000000000        0.0000000000000000        46.000000000000000        0.0000000000000000        118.00000000000000        0.0000000000000000        142.00000000000000        0.0000000000000000     
 C           0   19.000000000000000        0.0000000000000000        39.000000000000000        0.0000000000000000        99.000000000000000        0.0000000000000000        119.00000000000000        0.0000000000000000     
 C           3   70.000000000000000        0.0000000000000000        94.000000000000000        0.0000000000000000        166.00000000000000        0.0000000000000000        190.00000000000000        0.0000000000000000     
 C           1   59.000000000000000        0.0000000000000000        79.000000000000000        0.0000000000000000        139.00000000000000        0.0000000000000000        159.00000000000000        0.0000000000000000     
</code></pre></div></div>

<p>计算结果与matlab吻合</p>

<p><img src="/uploads/2019/04/matlab.jpg" alt="" /></p>

<h4 id="示例程序-2-将已有矩阵进行重新分发2019-04-30">示例程序 2. 将已有矩阵进行重新分发(2019-04-30)</h4>

<p>新的理解，关于scalapack的计算网格分发和数据的分发
<img src="/uploads/2019/04/scalapack1.jpg" alt="" />
<img src="/uploads/2019/04/scalapack2.jpg" alt="" /></p>

<div class="language-fortran highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">program</span><span class="w"> </span><span class="n">test</span><span class="w">
    </span><span class="k">use</span><span class="w"> </span><span class="n">m_mpi_my</span><span class="w">
    </span><span class="k">implicit</span><span class="w"> </span><span class="k">none</span><span class="w">
    </span><span class="kt">INTEGER</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">dp</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="w">
    </span><span class="kt">REAL</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span><span class="n">B</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="w">
    </span><span class="kt">INTEGER</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">AICTXT</span><span class="p">,</span><span class="w"> </span><span class="n">BICTXT</span><span class="p">,</span><span class="n">ctxt_sys</span><span class="p">,</span><span class="n">EICTXT</span><span class="w">
    </span><span class="kt">INTEGER</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">NPROW</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">NPCOL</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">IRREAD</span><span class="p">,</span><span class="n">ICREAD</span><span class="p">,</span><span class="n">MYROW</span><span class="p">,</span><span class="n">MYCOL</span><span class="w">
    </span><span class="kt">INTEGER</span><span class="p">,</span><span class="k">PARAMETER</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">DLEN_</span><span class="o">=</span><span class="mi">9</span><span class="w">
    </span><span class="kt">INTEGER</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">DESCA</span><span class="p">(</span><span class="n">DLEN_</span><span class="p">),</span><span class="n">DESCB</span><span class="p">(</span><span class="n">DLEN_</span><span class="p">)</span><span class="w">
    </span><span class="kt">INTEGER</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">INFO</span><span class="w">    
    </span><span class="c1">!===Init=======    </span><span class="w">
    </span><span class="k">call</span><span class="w"> </span><span class="n">mpi_start</span><span class="p">()</span><span class="w">
    </span><span class="k">call</span><span class="w"> </span><span class="n">SL_INIT</span><span class="p">(</span><span class="n">ctxt_sys</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">NPCOL</span><span class="p">)</span><span class="w">    

    </span><span class="n">AICTXT</span><span class="o">=</span><span class="n">ctxt_sys</span><span class="w">
    </span><span class="k">call</span><span class="w"> </span><span class="n">BLACS_GRIDINIT</span><span class="p">(</span><span class="n">AICTXT</span><span class="p">,</span><span class="s1">'R'</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="w">
    
    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">AICTXT</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w">
        </span><span class="k">call</span><span class="w"> </span><span class="n">DESCINIT</span><span class="p">(</span><span class="n">DESCA</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">AICTXT</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">INFO</span><span class="p">)</span><span class="w">
    </span><span class="k">endif</span><span class="w">
    </span><span class="n">BICTXT</span><span class="o">=</span><span class="n">ctxt_sys</span><span class="w">
    </span><span class="k">call</span><span class="w"> </span><span class="n">BLACS_GRIDINIT</span><span class="p">(</span><span class="n">BICTXT</span><span class="p">,</span><span class="s1">'R'</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">BICTXT</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w">
    </span><span class="k">call</span><span class="w"> </span><span class="n">DESCINIT</span><span class="p">(</span><span class="n">DESCB</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">BICTXT</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">INFO</span><span class="p">)</span><span class="w">
    </span><span class="k">endif</span><span class="w">
    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">IOnode</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w">
        </span><span class="k">do</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="w">
            </span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="w">
            </span><span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">=</span><span class="mf">10.0</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="mi">-1</span><span class="p">)</span><span class="o">+</span><span class="n">j</span><span class="w">
            </span><span class="k">enddo</span><span class="w">
        </span><span class="k">enddo</span><span class="w">
    </span><span class="k">else</span><span class="w">
        </span><span class="n">A</span><span class="o">=</span><span class="mf">20.0</span><span class="w">
    </span><span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="w">
    </span><span class="k">if</span><span class="p">(</span><span class="n">BICTXT</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w">
    </span><span class="k">call</span><span class="w"> </span><span class="n">psgemr2d</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">DESCA</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">DESCB</span><span class="p">,</span><span class="w"> </span><span class="n">BICTXT</span><span class="p">)</span><span class="w">
    </span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">node</span><span class="p">,</span><span class="n">B</span><span class="w">
    </span><span class="k">endif</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">AICTXT</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">CALL</span><span class="w"> </span><span class="n">BLACS_GRIDEXIT</span><span class="p">(</span><span class="w"> </span><span class="n">AICTXT</span><span class="w"> </span><span class="p">)</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">BICTXT</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">CALL</span><span class="w"> </span><span class="n">BLACS_GRIDEXIT</span><span class="p">(</span><span class="w"> </span><span class="n">BICTXT</span><span class="w"> </span><span class="p">)</span><span class="w">
    </span><span class="k">CALL</span><span class="w"> </span><span class="n">BLACS_EXIT</span><span class="p">(</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w">
   
    </span><span class="c1">!call mpi_end()    </span><span class="w">
</span><span class="k">end</span><span class="w"> </span><span class="k">program</span><span class="w"> </span><span class="n">test</span><span class="w">
</span></code></pre></div></div>
<p>计算结果，成功分发</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cndaqiang@win10:~/code/TDAP/Fortran/scalapack&gt; mpirun -np 3 ./test
           0   1.00000000       11.0000000       2.00000000       12.0000000
           1   3.00000000       13.0000000       4.00000000       14.0000000
</code></pre></div></div>

<h4 id="数据读写">数据读写</h4>
<p>mkl不支持数据读写，Netlib支持</p>
<div class="language-fortran highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#读</span><span class="w">
    </span><span class="k">call</span><span class="w"> </span><span class="n">PdLAREAD</span><span class="p">(</span><span class="s2">"H.data"</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">DESCH</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">WORK</span><span class="p">)</span><span class="w">
    </span><span class="err">#</span><span class="n">work</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w">
</span><span class="cp">#写</span><span class="w">
    </span><span class="k">call</span><span class="w"> </span><span class="n">PdLAWRITE</span><span class="p">(</span><span class="s2">"out.data"</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">DESCH</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">work</span><span class="p">)</span><span class="w">
    </span><span class="err">#</span><span class="n">work</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">k</span><span class="o">&gt;=</span><span class="n">MB</span><span class="w">
    </span><span class="err">#</span><span class="n">http</span><span class="p">://</span><span class="n">www</span><span class="ow">.netlib.</span><span class="n">org</span><span class="p">/</span><span class="n">scalapack</span><span class="p">/</span><span class="n">explore</span><span class="o">-</span><span class="n">html</span><span class="p">/</span><span class="n">d1</span><span class="p">/</span><span class="n">d81</span><span class="p">/</span><span class="n">pdlawrite_8f_source</span><span class="err">.</span><span class="n">html</span><span class="w">
    
</span></code></pre></div></div>

<h2 id="blaslapackscalapack编译">BLAS，Lapack，ScaLapack编译</h2>
<p><strong>注：此处使用gcc-4.8.4(Centos)编译通过，高版本gcc(Debian 6.3.0)编译有问题</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tar xzvf blas.tgz 
cd BLAS-3.8.0/
mpif90 -c *.f
ar cr librefblas.a *.o
ls *.a
cd ..
ls
tar xzvf lapack.tgz 
cd lapack-3.8.0/
cp make.inc.example make.inc
vi make.inc
</code></pre></div></div>
<p>修改</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FORTRAN = Fortran编译器
LOADER   = Fortran编译器
#BLASLIB用绝对路径
BLASLIB      = /public/home/cndaqiang/soft/mvapich-2.3.1/source/scalapack_installer/build/download/BLAS-3.8.0/librefblas.a
</code></pre></div></div>
<p>继续</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make
ls *.a
cd ..
tar xzvf scalapack.tgz 
cd scalapack-2.0.2/
ls
cp SLmake.inc.example SLmake.inc
vi SLmake.inc
</code></pre></div></div>
<p>修改</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FC            = mpif90
CC            = mpicc
BLASLIB       = /public/home/cndaqiang/soft/mvapich-2.3.1/source/scalapack_installer/build/download/BLAS-3.8.0/librefblas.a
LapackLIB     = /public/home/cndaqiang/soft/mvapich-2.3.1/source/scalapack_installer/build/download/lapack-3.8.0/liblapack.a /public/home/cndaqiang/soft/mvapich-2.3.1/source/scalapack_installer/build/download/lapack-3.8.0/libtmglib.a
</code></pre></div></div>
<p>继续</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make
</code></pre></div></div>

<p>在siesta中使用</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MATHDIR=/public/home/cndaqiang/soft/mvapich-2.3.1/math
BLAS_LIBS=$(MATHDIR)/librefblas.a
Lapack_LIBS=$(MATHDIR)/liblapack.a $(MATHDIR)/libtmglib.a
BLACS_LIBS=
SCALapack_LIBS=$(MATHDIR)/libscalapack.a
</code></pre></div></div>

<h3 id="编译报错原因">编译报错原因</h3>
<h4 id="库和编译器不匹配">库和编译器不匹配</h4>
<p>多发生在使用gcc和openmpi编译的数学库，调用mpicc时是intel的编译器</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mpif90  -g -O2 -ffree-line-length-none    -o test  mytest.f90 m_mpi_my.o  -L/home/cndaqiang/soft/OPENMPI-GCC/LIB/mathlib -lrefblas -llapack  -lscalapack  -ltmglib  
/home/cndaqiang/soft/OPENMPI-GCC/LIB/mathlib/libscalapack.a(blacs_get_.o): In function `blacs_get_':
blacs_get_.c:(.text+0x92): undefined reference to `ompi_mpi_comm_world'
blacs_get_.c:(.text+0xd3): undefined reference to `MPI_Comm_c2f'
/home/cndaqiang/soft/OPENMPI-GCC/LIB/mathlib/libscalapack.a(blacs_pinfo_.o): In function `blacs_pinfo_':
blacs_pinfo_.c:(.text+0x61): undefined reference to `ompi_mpi_comm_world'
blacs_pinfo_.c:(.text+0x70): undefined reference to `MPI_Comm_c2f'
blacs_pinfo_.c:(.text+0x7a): undefined reference to `ompi_mpi_comm_world'
blacs_pinfo_.c:(.text+0x8d): undefined reference to `ompi_mpi_comm_world'
</code></pre></div></div>

<h4 id="库的链接顺序有要求">库的链接顺序有要求</h4>
<p>先链接<code class="highlighter-rouge">scalapack</code>的库</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MATHDIR=/home/cndaqiang/soft/scalapack/lib
BLAS_LIBS=$(MATHDIR)/librefblas.a
Lapack_LIBS=$(MATHDIR)/libreflapack.a $(MATHDIR)/libtmg.a
BLACS_LIBS=
SCALapack_LIBS=$(MATHDIR)/libscalapack.a
LIBS=$(SCALapack_LIBS) $(BLACS_LIBS) $(Lapack_LIBS) $(BLAS_LIBS)
</code></pre></div></div>
<p>若将<code class="highlighter-rouge">blas</code>放在<code class="highlighter-rouge">scalapack</code>前会发生下面报错</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mpif90  -g -O2 -ffree-line-length-none    -o test  mytest.f90 m_mpi_my.o      /home/cndaqiang/soft/scalapack/lib/librefblas.a  /home/cndaqiang/soft/scalapack/lib/libtmg.a /home/cndaqiang/soft/scalapack/lib/libscalapack.a   /home/cndaqiang/soft/scalapack/lib/libreflapack.a
/home/cndaqiang/soft/scalapack/lib/libscalapack.a(PB_Cdtypeset.o): In function `PB_Cdtypeset':
PB_Cdtypeset.c:(.text+0x183): undefined reference to `daxpy_'
PB_Cdtypeset.c:(.text+0x18e): undefined reference to `dcopy_'
PB_Cdtypeset.c:(.text+0x199): undefined reference to `dswap_'
PB_Cdtypeset.c:(.text+0x1a4): undefined reference to `dgemv_'
</code></pre></div></div>

<h2 id="fft">FFT</h2>
<p>原理<br />
<img src="/uploads/2019/05/fft.jpg" alt="" /></p>

<h3 id="fftw3">FFTW3</h3>
<p>编译连接，Fortran要<code class="highlighter-rouge">-I</code>指定include目录，并指定<code class="highlighter-rouge">fftw.a</code></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gfortran  -I/home/cndaqiang/soft/OPENMPI_1.10.3-GCC-4.8.5-opensuse/mathlib/fftw-3.3.4/include -o test bohanshufftw.o  /home/cndaqiang/soft/OPENMPI_1.10.3-GCC-4.8.5-opensuse/mathlib/fftw-3.3.4/lib/libfftw3.a
</code></pre></div></div>
<p>使用方法：1建立网格点-&gt;2计算FFT-&gt;3释放网格点
使用示例,合解释说明<br />
2维FFT与IFFT</p>

<div class="language-fortran highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><span class="w">
</span><span class="c1">!!!   ___                               _            _     _                       _  !!!</span><span class="w">
</span><span class="c1">!!!  / __|  ___   _ __    _ __   _  _  | |_   __ _  | |_  (_)  ___   _ _    __ _  | | !!!</span><span class="w">
</span><span class="c1">!!! | (__  / _ \ | '  \  | '_ \ | || | |  _| / _` | |  _| | | / _ \ | ' \  / _` | | | !!!</span><span class="w">
</span><span class="c1">!!!  \___| \___/ |_|_|_| | .__/  \_,_|  \__| \__,_|  \__| |_| \___/ |_||_| \__,_| |_| !!!</span><span class="w">
</span><span class="c1">!!!  ___   _             |_|  _                                                       !!!</span><span class="w">
</span><span class="c1">!!! | _ \ | |_    _  _   ___ (_)  __   ___                                            !!!</span><span class="w">
</span><span class="c1">!!! |  _/ | ' \  | || | (_-&lt; | | / _| (_-&lt;                                            !!!</span><span class="w">
</span><span class="c1">!!! |_|   |_||_|  \_, | /__/ |_| \__| /__/                                            !!!</span><span class="w">
</span><span class="c1">!!!  _  _         |__/                               _                                !!!</span><span class="w">
</span><span class="c1">!!! | || |  ___   _ __    ___  __ __ __  ___   _ _  | |__                             !!!</span><span class="w">
</span><span class="c1">!!! | __ | / _ \ | '  \  / -_) \ V  V / / _ \ | '_| | / /                             !!!</span><span class="w">
</span><span class="c1">!!! |_||_| \___/ |_|_|_| \___|  \_/\_/  \___/ |_|   |_\_\                             !!!</span><span class="w">
</span><span class="c1">!!!                                                                                   !!!</span><span class="w">
</span><span class="c1">!!! Author:       cndaqiang                                                           !!!</span><span class="w">
</span><span class="c1">!!! ContactMe:    https://cndaqiang.github.io                                         !!! </span><span class="w">
</span><span class="c1">!!! Name:         bohanshufftw                                                          !!!</span><span class="w">
</span><span class="c1">!!! Last-update:  2019-05-23                                                          !!!</span><span class="w">
</span><span class="c1">!!! Build-time:   2019-05-23                                                          !!!</span><span class="w">
</span><span class="c1">!!! What it is:   波函数fft与ifft计算                                    !!!</span><span class="w">
</span><span class="c1">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><span class="w">

</span><span class="k">program</span><span class="w"> </span><span class="n">bohanshufftw</span><span class="w">
    </span><span class="k">use</span><span class="p">,</span><span class="k">intrinsic</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">iso_c_binding</span><span class="w">
    </span><span class="k">implicit</span><span class="w"> </span><span class="k">none</span><span class="w">
    </span><span class="k">include</span><span class="w"> </span><span class="s1">'fftw3.f03'</span><span class="w">
    </span><span class="kt">INTEGER</span><span class="p">,</span><span class="k">PARAMETER</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">N</span><span class="o">=</span><span class="mi">50</span><span class="w"> </span><span class="c1">!N=600</span><span class="w">
    </span><span class="kt">INTEGER</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="w">
    </span><span class="c1">!波函数f(x)=c1*exp(-i*2*pi*f1*x)+c2*exp(-i*2*pi*f2*x)</span><span class="w">
    </span><span class="kt">REAL</span><span class="p">,</span><span class="k">PARAMETER</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">pi</span><span class="o">=</span><span class="mf">3.1415926</span><span class="w">
    </span><span class="kt">REAL</span><span class="p">(</span><span class="n">C_DOUBLE</span><span class="p">)::</span><span class="n">x</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">),</span><span class="n">y</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">),</span><span class="n">kx</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">),</span><span class="n">ky</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">),</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="p">,</span><span class="n">k1x</span><span class="p">,</span><span class="n">k1y</span><span class="p">,</span><span class="n">c1</span><span class="p">,</span><span class="n">k2x</span><span class="p">,</span><span class="n">k2y</span><span class="p">,</span><span class="n">c2</span><span class="w">
    </span><span class="kt">complex</span><span class="p">(</span><span class="n">C_DOUBLE_COMPLEX</span><span class="p">)</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">fxy</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">),</span><span class="n">fk</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">),</span><span class="n">ffxy</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="c1">!fx-FFT-&gt;fk-IFFT-&gt;ffx </span><span class="w">
    </span><span class="kt">REAL</span><span class="p">(</span><span class="n">C_DOUBLE</span><span class="p">)</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">realf</span><span class="p">,</span><span class="n">imagef</span><span class="w">
    </span><span class="k">type</span><span class="p">(</span><span class="n">C_PTR</span><span class="p">)</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">planfft</span><span class="p">,</span><span class="n">planifft</span><span class="w">
    </span><span class="kt">complex</span><span class="p">(</span><span class="n">C_DOUBLE_COMPLEX</span><span class="p">),</span><span class="k">dimension</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="k">in</span><span class="p">,</span><span class="k">out</span><span class="w">
    </span><span class="n">k1x</span><span class="o">=</span><span class="mi">20</span><span class="w"> </span><span class="c1">!k1x</span><span class="w">
    </span><span class="n">k1y</span><span class="o">=</span><span class="mi">30</span><span class="w"> </span><span class="c1">!ky</span><span class="w">
    </span><span class="n">c1</span><span class="o">=</span><span class="nb">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="p">/</span><span class="mf">3.0</span><span class="p">)</span><span class="w">
    </span><span class="n">k2x</span><span class="o">=</span><span class="mi">5</span><span class="w">
    </span><span class="n">k2y</span><span class="o">=</span><span class="mi">7</span><span class="w">
    </span><span class="n">c2</span><span class="o">=</span><span class="nb">sqrt</span><span class="p">(</span><span class="mf">1.0</span><span class="p">/</span><span class="mf">3.0</span><span class="p">)</span><span class="w">
    </span><span class="n">dx</span><span class="o">=</span><span class="mf">0.02</span><span class="w">
    </span><span class="n">dy</span><span class="o">=</span><span class="n">dx</span><span class="w">
    </span><span class="k">DO</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w">
        </span><span class="k">Do</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w">
        </span><span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="mf">-1.0</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span><span class="w">
        </span><span class="n">kx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="mf">-1.0</span><span class="p">)/</span><span class="n">N</span><span class="p">/</span><span class="n">dx</span><span class="w">
        </span><span class="n">y</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">=</span><span class="p">(</span><span class="n">j</span><span class="mf">-1.0</span><span class="p">)</span><span class="o">*</span><span class="n">dy</span><span class="w">
        </span><span class="n">ky</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">=</span><span class="p">(</span><span class="n">j</span><span class="mf">-1.0</span><span class="p">)/</span><span class="n">N</span><span class="p">/</span><span class="n">dy</span><span class="w">
        </span><span class="n">realf</span><span class="o">=</span><span class="n">c1</span><span class="o">*</span><span class="nb">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">k1x</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="n">k1y</span><span class="o">*</span><span class="n">y</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)))</span><span class="o">+</span><span class="n">c2</span><span class="o">*</span><span class="nb">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">k2x</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="n">k2y</span><span class="o">*</span><span class="n">y</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)))</span><span class="w">
        </span><span class="n">imagef</span><span class="o">=</span><span class="n">c1</span><span class="o">*</span><span class="nb">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">k1x</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="n">k1y</span><span class="o">*</span><span class="n">y</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)))</span><span class="o">+</span><span class="n">c2</span><span class="o">*</span><span class="nb">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">k2x</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="n">k2y</span><span class="o">*</span><span class="n">y</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)))</span><span class="w">
        </span><span class="n">fxy</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">=</span><span class="nb">cmplx</span><span class="p">(</span><span class="n">realf</span><span class="p">,</span><span class="n">imagef</span><span class="p">)</span><span class="w">
        </span><span class="k">END</span><span class="w"> </span><span class="k">DO</span><span class="w">
    </span><span class="k">END</span><span class="w"> </span><span class="k">DO</span><span class="w">

    
    </span><span class="c1">!数据结构类型</span><span class="w">
    </span><span class="c1">!FFTW plans are type(C_PTR). </span><span class="w">
    </span><span class="c1">!Other C types are mapped in the obvious way via the iso_c_binding standard:</span><span class="w">
    </span><span class="c1">!int turns into integer(C_INT), </span><span class="w">
    </span><span class="c1">!fftw_complex turns into complex(C_DOUBLE_COMPLEX), </span><span class="w">
    </span><span class="c1">!double turns into real(C_DOUBLE), and so on. </span><span class="w">
    </span><span class="c1">!See Section 7.3 [FFTW Fortran type reference], page 80. </span><span class="w">
</span><span class="c1">!-------------------</span><span class="w">
    </span><span class="c1">!实数</span><span class="w">
    </span><span class="c1">!REAL: real(C_DOUBLE), real(C_FLOAT), and real(C_LONG_DOUBLE)</span><span class="w">
</span><span class="c1">!-------------------</span><span class="w">
    </span><span class="c1">!复数</span><span class="w">
    </span><span class="c1">!fftw_complex, fftwf_complex, and fftwl_complex </span><span class="w">
    </span><span class="c1">!complex(C_DOUBLE_COMPLEX), complex(C_FLOAT_COMPLEX), and complex(C_LONG_DOUBLE_COMPLEX)</span><span class="w">
</span><span class="c1">!------fftw编译类型及调用方法</span><span class="w">
    </span><span class="c1">!the FFTW subroutines and types are prefixed with </span><span class="w">
    </span><span class="c1">!‘fftw_’, fftwf_, and fftwl_ for the different precisions, </span><span class="w">
    </span><span class="c1">!and link to different libraries (-lfftw3, -lfftw3f, and -lfftw3l on Unix)</span><span class="w">
    </span><span class="c1">!libfftw3.a这个应该是double的意思</span><span class="w">
    </span><span class="c1">!use the same include file fftw3.f03 </span><span class="w">
    </span><span class="c1">!and the same constants (all of which begin with ‘FFTW_’)</span><span class="w">
    </span><span class="c1">!编译时，指定fftw时指定参数 --enable-float --enable-long-double 默认是double, </span><span class="w">
    </span><span class="c1">!--enable-avx等等是指令集 FFTW 支持 SSE、SSE2、 Altivec 和 MIPS 指令集</span><span class="w">
    </span><span class="c1">!一次只能编译成一种类型</span><span class="w">
    </span><span class="c1">!这就是超算上fftw有多种版本的原因吧</span><span class="w">
    </span><span class="c1">!2.1.5-double  3.3.4-double-avx        3.3.4-icc-float   3.3.4-single-avx       3.3.5-double</span><span class="w">
    </span><span class="c1">!3.3.4         3.3.4-double-avx-sse2   3.3.4-icc-single  3.3.4-single-avx-sse2  3.4.4</span><span class="w">
    </span><span class="c1">!3.3.4-centos  3.3.4-double-fma-icc15  3.3.4-MPI         3.3.4-SSE2             mkl-14</span><span class="w">
    </span><span class="c1">!3.3.4-double  3.3.4-gcc               3.3.4-MPICH2.1.5  3.3.5</span><span class="w">
    </span><span class="c1">!用double就行了</span><span class="w">
    </span><span class="c1">!将所有以小写"fftw_"开头的名字替换为"fftwf_"（float版本）或"fftwl_"（long double版本）。</span><span class="w">
    </span><span class="c1">!比如将fftw_complex替换为fftwf_complex，将fftw_execute替换为fftwf_execute等。</span><span class="w">
    </span><span class="c1">!所有以大写"FFTW_"开头的名字不变</span><span class="w">
</span><span class="c1">!-------------------</span><span class="w">
    </span><span class="c1">!整数</span><span class="w">
    </span><span class="c1">!The C integer types int and unsigned (used for planner flags) </span><span class="w">
    </span><span class="c1">!become integer(C_ INT).</span><span class="w">
</span><span class="c1">!-------------------    </span><span class="w">
    </span><span class="c1">!数组</span><span class="w">
    </span><span class="c1">!Numeric array pointer arguments (e.g. double *) become dimension(*),</span><span class="w">
</span><span class="c1">!-------------------</span><span class="w">
</span><span class="c1">!===========================================================</span><span class="w">
</span><span class="c1">!------------------------</span><span class="w">
    </span><span class="c1">!建立网格点</span><span class="w">
    </span><span class="c1">!plan = fftw_plan_dft_2d(1000,1024,in,out,FFTW_FO RWARD,FFTW_ESTIMATE)</span><span class="w">
    </span><span class="c1">!planr2c = fftw_plan_dft_r2c_1d(N,ytr,fftyc,FFTW_ESTIMATE)</span><span class="w">
    </span><span class="c1">!plan = fftw_plan_dft_1d(N,ytc,ffty,FFTW_FORWARD,FFTW_ESTIMATE)</span><span class="w">
    </span><span class="c1">!planc2r = fftw_plan_dft_c2r_1d(N,ytc2r,fftyc2r,FFTW_ESTIMATE)</span><span class="w">
    </span><span class="c1">!其他类型的网格点，如 fftw_plan_dft_r2c_3d</span><span class="w">
    </span><span class="n">planfft</span><span class="o">=</span><span class="n">fftw_plan_dft_2d</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="k">in</span><span class="p">,</span><span class="k">out</span><span class="p">,</span><span class="n">FFTW_FORWARD</span><span class="p">,</span><span class="n">FFTW_ESTIMATE</span><span class="p">)</span><span class="w">
    </span><span class="n">planifft</span><span class="o">=</span><span class="n">fftw_plan_dft_2d</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="k">in</span><span class="p">,</span><span class="k">out</span><span class="p">,</span><span class="n">FFTW_BACKWARD</span><span class="p">,</span><span class="n">FFTW_ESTIMATE</span><span class="p">)</span><span class="w">
    </span><span class="c1">!dft,dft_r2c,dft_c2r,r2r,解释见下,注r2r没有dft</span><span class="w">
    </span><span class="c1">!维度1d,2d,3d</span><span class="w">
    </span><span class="c1">!fftw_plan_dft_2d(N1,N2,in,out,FFTW_FORWARD,FFTW_ESTIMATE)</span><span class="w">
    </span><span class="c1">!网格点N1*N2,输入输出矩阵in,out</span><span class="w">
    </span><span class="c1">!sign表示是做DFT变换 FFTW_FORWARD == -1 *exp(-2*pi*fn*x)</span><span class="w">
    </span><span class="c1">!还是逆FFT变换 IDFT  FFTW_BACKWARD == +1 *exp(+2*pi*fn*x)</span><span class="w">
    </span><span class="c1">!优化方案</span><span class="w">
    </span><span class="c1">!flags是策略生成方案。一般情况下为FFTW MEASURE或FFTW </span><span class="w">
    </span><span class="c1">!FFTW_MEASURE表示FFTW会先计算一些FFT并测量所用的时间，以便为大小为n的变换寻找最优的计算方法。 </span><span class="w">
    </span><span class="c1">!FFTW_ESTIMATE则相反，它直接构造一个合理的但可能是次最优的方案。</span><span class="w">
    
    
</span><span class="c1">!-----------------------</span><span class="w">
    </span><span class="c1">!执行计算</span><span class="w">
    </span><span class="c1">!call fftw_EXECUTE_dft_r2c(plan,y,ffty)</span><span class="w">
    </span><span class="c1">!call fftw_EXECUTE_dft(plan,ytc,ffty)</span><span class="w">
    </span><span class="c1">!call fftw_execute_dft_r2c(planr2c,ytr,fftyc)</span><span class="w">
    </span><span class="c1">!call fftw_EXECUTE_dft_c2r(planc2r,ytc2r,fftyc2r)</span><span class="w">
    </span><span class="c1">! planc2r = fftw_plan_dft_c2r_1d(N,ytc,fftyc2r,FFTW_ESTIMATE)</span><span class="w">
    </span><span class="k">call</span><span class="w"> </span><span class="n">fftw_EXECUTE_dft</span><span class="p">(</span><span class="n">planfft</span><span class="p">,</span><span class="n">fxy</span><span class="p">,</span><span class="n">fk</span><span class="p">)</span><span class="w">
    </span><span class="n">fk</span><span class="o">=</span><span class="n">fk</span><span class="p">/(</span><span class="n">N</span><span class="o">*</span><span class="n">N</span><span class="p">)</span><span class="w">
    </span><span class="k">call</span><span class="w"> </span><span class="n">fftw_EXECUTE_dft</span><span class="p">(</span><span class="n">planifft</span><span class="p">,</span><span class="n">fk</span><span class="p">,</span><span class="n">ffxy</span><span class="p">)</span><span class="w">
</span><span class="c1">!call fftw_execute(plan)也可以计算，但Fortran优化后经常出错，不要用</span><span class="w">
</span><span class="c1">!计算网格命令要和创建网格命令匹配    </span><span class="w">
</span><span class="c1">!You must use the correct type of execute function,</span><span class="w">
</span><span class="c1">! matching the way the plan was created. </span><span class="w">
</span><span class="c1">!默认c2c即不写</span><span class="w">
</span><span class="c1">!Complex DFT plans should use fftw_execute_dft, </span><span class="w">
</span><span class="c1">!input实数(REAL)-&gt;output复数(COMPLEX): r2c</span><span class="w">
</span><span class="c1">!Real-input (r2c) DFT plans should use use fftw_execute_dft_r2c</span><span class="w">
</span><span class="c1">!复数-&gt;实数：c2r</span><span class="w">
</span><span class="c1">!and real-output (c2r) DFT plans should use fftw_execute_dft_c2r. </span><span class="w">
</span><span class="c1">!实数—&gt;实数：r2r</span><span class="w">
</span><span class="c1">!The various r2r plans should use fftw_execute_r2r   </span><span class="w">
    
</span><span class="c1">!-----------------------    </span><span class="w">
    </span><span class="k">open</span><span class="p">(</span><span class="n">unit</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span><span class="n">file</span><span class="o">=</span><span class="s2">"fxy.dat"</span><span class="p">)</span><span class="w">
    </span><span class="k">open</span><span class="p">(</span><span class="n">unit</span><span class="o">=</span><span class="mi">13</span><span class="p">,</span><span class="n">file</span><span class="o">=</span><span class="s2">"fk.dat"</span><span class="p">)</span><span class="w">
    </span><span class="k">open</span><span class="p">(</span><span class="n">unit</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span><span class="n">file</span><span class="o">=</span><span class="s2">"ffxy.dat"</span><span class="p">)</span><span class="w">
    </span><span class="k">DO</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w">
        </span><span class="k">Do</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="w">
        </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">/</span><span class="mi">2</span><span class="w"> </span><span class="ow">.and.</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="n">N</span><span class="p">/</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w">
            </span><span class="k">write</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="n">y</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="nb">abs</span><span class="p">(</span><span class="n">fxy</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">))</span><span class="w">
            </span><span class="k">write</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="n">y</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="nb">abs</span><span class="p">(</span><span class="n">ffxy</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">))</span><span class="w">
        </span><span class="k">endif</span><span class="w">
        </span><span class="k">write</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">kx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="n">ky</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="nb">abs</span><span class="p">(</span><span class="n">fk</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">))</span><span class="w">
        </span><span class="k">END</span><span class="w"> </span><span class="k">DO</span><span class="w">
    </span><span class="k">END</span><span class="w"> </span><span class="k">DO</span><span class="w">
    </span><span class="c1">!</span><span class="w">
    </span><span class="c1">!Do i = N-5,N</span><span class="w">
    </span><span class="c1">!   write(*,*) fftx(i),fftyc2r(i)/N </span><span class="w">
    </span><span class="c1">!END DO</span><span class="w">
    </span><span class="c1">!</span><span class="w">
    </span><span class="c1">!write(*,*) "------------------------"</span><span class="w">
    </span><span class="c1">!DO i = 1,6</span><span class="w">
    </span><span class="c1">!    write(*,*) fftx(i),ffty(i)/N</span><span class="w">
    </span><span class="c1">!END DO</span><span class="w">
    </span><span class="c1">!</span><span class="w">
    </span><span class="c1">!Do i = N-5,N</span><span class="w">
    </span><span class="c1">!   write(*,*) fftx(i),ffty(i)/N </span><span class="w">
    </span><span class="c1">!END DO</span><span class="w">
    </span><span class="c1">!释放网格点</span><span class="w">
    </span><span class="c1">!call fftw_destroy_plan(planr2c)</span><span class="w">
    </span><span class="c1">!call fftw_destroy_plan(plan)</span><span class="w">
    </span><span class="k">call</span><span class="w"> </span><span class="n">fftw_destroy_plan</span><span class="p">(</span><span class="n">planfft</span><span class="p">)</span><span class="w">
    </span><span class="k">call</span><span class="w"> </span><span class="n">fftw_destroy_plan</span><span class="p">(</span><span class="n">planifft</span><span class="p">)</span><span class="w">
    </span><span class="c1">! </span><span class="w">
</span><span class="k">end</span><span class="w"> </span><span class="k">program</span><span class="w"> </span><span class="n">bohanshufftw</span><span class="w">
</span></code></pre></div></div>
<p>其中一次的计算结果
<img src="/uploads/2019/05/fftwbo.jpg" alt="" /></p>
:ET