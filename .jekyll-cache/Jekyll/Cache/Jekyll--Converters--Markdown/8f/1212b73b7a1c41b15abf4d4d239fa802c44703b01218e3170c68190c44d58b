I"!<ul id="markdown-toc">
  <li><a href="#参考" id="markdown-toc-参考">参考</a></li>
  <li><a href="#数据类型" id="markdown-toc-数据类型">数据类型</a>    <ul>
      <li><a href="#1数值" id="markdown-toc-1数值">1.数值</a></li>
      <li><a href="#2字符串" id="markdown-toc-2字符串">2.字符串</a>        <ul>
          <li><a href="#21单引号" id="markdown-toc-21单引号">2.1单引号</a></li>
          <li><a href="#22双引号" id="markdown-toc-22双引号">2.2双引号</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#变量数组" id="markdown-toc-变量数组">变量&amp;数组</a>    <ul>
      <li><a href="#1变量" id="markdown-toc-1变量">1.变量</a>        <ul>
          <li><a href="#11定义使用" id="markdown-toc-11定义使用">1.1定义，使用</a></li>
          <li><a href="#12只读变量" id="markdown-toc-12只读变量">1.2只读变量</a></li>
          <li><a href="#13删除变量" id="markdown-toc-13删除变量">1.3删除变量</a></li>
          <li><a href="#14变量类型" id="markdown-toc-14变量类型">1.4变量类型</a></li>
        </ul>
      </li>
      <li><a href="#2数组" id="markdown-toc-2数组">2.数组</a>        <ul>
          <li><a href="#21定义使用" id="markdown-toc-21定义使用">2.1定义，使用</a></li>
          <li><a href="#22获取数组长度" id="markdown-toc-22获取数组长度">2.2获取数组长度</a></li>
        </ul>
      </li>
      <li><a href="#3-字典" id="markdown-toc-3-字典">3 字典</a></li>
    </ul>
  </li>
  <li><a href="#bash文件" id="markdown-toc-bash文件">bash文件</a></li>
  <li><a href="#注释" id="markdown-toc-注释">注释</a></li>
  <li><a href="#运算" id="markdown-toc-运算">运算</a>    <ul>
      <li><a href="#1-数值运算" id="markdown-toc-1-数值运算">1 数值运算</a></li>
      <li><a href="#2-字符串运算" id="markdown-toc-2-字符串运算">2 字符串运算</a></li>
      <li><a href="#21字符串的使用" id="markdown-toc-21字符串的使用">2.1字符串的使用</a></li>
      <li><a href="#22-字符串操作" id="markdown-toc-22-字符串操作">2.2 字符串操作</a></li>
    </ul>
  </li>
  <li><a href="#流程控制判断循环" id="markdown-toc-流程控制判断循环">流程控制(判断循环)</a>    <ul>
      <li><a href="#1-条件判断" id="markdown-toc-1-条件判断">1 条件判断</a>        <ul>
          <li><a href="#11-test" id="markdown-toc-11-test">1.1 <strong>test</strong></a></li>
          <li><a href="#12-条件判断" id="markdown-toc-12-条件判断">1.2 <code class="highlighter-rouge">[]</code>条件判断</a></li>
          <li><a href="#13-逻辑" id="markdown-toc-13-逻辑">1.3 逻辑</a></li>
        </ul>
      </li>
      <li><a href="#2-if----then-cmd-elif------then-cmd---else-cmd--fi" id="markdown-toc-2-if----then-cmd-elif------then-cmd---else-cmd--fi">2 <code class="highlighter-rouge">if [ ] ; then cmd; elif  [ ] ;  then cmd ;  else cmd ; fi</code></a></li>
      <li><a href="#3-case" id="markdown-toc-3-case">3 case</a></li>
      <li><a href="#4-for循环" id="markdown-toc-4-for循环">4 for循环</a></li>
      <li><a href="#5-until" id="markdown-toc-5-until">5 until</a></li>
      <li><a href="#6-while" id="markdown-toc-6-while">6 while</a></li>
      <li><a href="#7-break-与continue" id="markdown-toc-7-break-与continue">7 break 与continue</a></li>
    </ul>
  </li>
  <li><a href="#函数" id="markdown-toc-函数">函数</a>    <ul>
      <li><a href="#1-定义" id="markdown-toc-1-定义">1 定义</a></li>
      <li><a href="#2-传递参数" id="markdown-toc-2-传递参数">2 传递参数</a></li>
      <li><a href="#内建命令" id="markdown-toc-内建命令">内建命令</a>        <ul>
          <li><a href="#1-内建指令查看" id="markdown-toc-1-内建指令查看">1 内建指令查看</a></li>
          <li><a href="#2-常用内建命令" id="markdown-toc-2-常用内建命令">2 常用内建命令</a></li>
          <li><a href="#echo" id="markdown-toc-echo">echo</a></li>
          <li><a href="#printf" id="markdown-toc-printf">printf</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#调试" id="markdown-toc-调试">调试</a>    <ul>
      <li><a href="#1-bash命令调试" id="markdown-toc-1-bash命令调试">1 bash命令调试</a></li>
      <li><a href="#2-echo调试" id="markdown-toc-2-echo调试">2 echo调试</a></li>
      <li><a href="#3-printf" id="markdown-toc-3-printf">3 printf</a></li>
    </ul>
  </li>
  <li><a href="#输入输出重定向" id="markdown-toc-输入输出重定向">输入输出重定向</a>    <ul>
      <li><a href="#输入重定向" id="markdown-toc-输入重定向">输入重定向</a></li>
      <li><a href="#输出重定向" id="markdown-toc-输出重定向">输出重定向</a></li>
      <li><a href="#绑定重定向" id="markdown-toc-绑定重定向">绑定重定向</a>        <ul>
          <li><a href="#文件描述符" id="markdown-toc-文件描述符">文件描述符</a></li>
        </ul>
      </li>
      <li><a href="#备注" id="markdown-toc-备注">备注</a>        <ul>
          <li><a href="#1---n等操作符可以同时出现在一条命令里而且无顺序要求如" id="markdown-toc-1---n等操作符可以同时出现在一条命令里而且无顺序要求如">1. &gt; &lt; n&gt;等操作符可以同时出现在一条命令里，而且无顺序要求，如</a></li>
          <li><a href="#2-命令行前面这一条ubuntuvm-10-194-ubuntutmp以及输入的命令在键盘上的显示好像属于标准错误输出" id="markdown-toc-2-命令行前面这一条ubuntuvm-10-194-ubuntutmp以及输入的命令在键盘上的显示好像属于标准错误输出">2. 命令行前面这一条<code class="highlighter-rouge">ubuntu@VM-10-194-ubuntu:/tmp$</code>以及输入的命令在键盘上的显示好像属于标准错误输出</a>            <ul>
              <li><a href="#3--命令--文件-中的命令应该能接受标准输入-命令--文件中的命令应该有标准输出" id="markdown-toc-3--命令--文件-中的命令应该能接受标准输入-命令--文件中的命令应该有标准输出">3.  <code class="highlighter-rouge">命令 &lt; 文件</code> 中的命令应该能接受标准输入 ，<code class="highlighter-rouge">命令 &gt; 文件</code>中的命令应该有标准输出</a></li>
            </ul>
          </li>
          <li><a href="#4-在类unix系统中devnull或称空设备是一个特殊的设备文件它丢弃一切写入其中的数据但报告写入操作成功读取它则会立即得到一个eof可以重定向输出到devnull" id="markdown-toc-4-在类unix系统中devnull或称空设备是一个特殊的设备文件它丢弃一切写入其中的数据但报告写入操作成功读取它则会立即得到一个eof可以重定向输出到devnull">4. 在类Unix系统中，<strong>/dev/null</strong>，或称<strong>空设备</strong>，是一个特殊的设备文件，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个EOF,可以重定向输出到/dev/null</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#其他传递" id="markdown-toc-其他传递">其他传递</a>    <ul>
      <li><a href="#管道" id="markdown-toc-管道">管道</a></li>
      <li><a href="#命令替换重音符" id="markdown-toc-命令替换重音符">命令替换(重音符`)</a></li>
    </ul>
  </li>
  <li><a href="#有趣" id="markdown-toc-有趣">有趣</a>    <ul>
      <li><a href="#多线程--与wait" id="markdown-toc-多线程--与wait">多线程 <code class="highlighter-rouge">&amp; </code>与<code class="highlighter-rouge">wait</code></a></li>
    </ul>
  </li>
  <li><a href="#还有好多需要学的留在下篇继续" id="markdown-toc-还有好多需要学的留在下篇继续">还有好多需要学的，留在下篇继续</a></li>
</ul>
<p>这篇文章之前写在简书上的，简书和这个博客的md语法有些差异，调节起来太麻烦了，以后复习bash时再重新整理</p>

<h1 id="参考">参考</h1>
<p><a href="http://www.cnblogs.com/skywang12345/archive/2013/05/30/3106570.html">Linux bash总结(一) 基础部分(适合初学者学习和非初学者参考)</a></p>

<p><a href="https://lug.ustc.edu.cn/OpenCourse/">Linux 入门公开课</a></p>

<p><a href="http://c.biancheng.net/cpp/shell/">C语言中文网-Shell教程</a></p>

<p><a href="http://zywqs.blog.51cto.com/1286606/843431">处理linux的echo命令不输出转义符号的问题</a></p>

<p><a href="http://www.runoob.com/linux/linux-shell.html">runoob-Shell 教程</a></p>

<p><a href="http://azaleasays.com/2008/02/25/linuxioredirect/">Linux标准输入/输出和重定向</a></p>

<p><a href="https://unmi.cc/linux-input-output-redirection/">Linux 输入输出重定向, &amp;&gt;file, 2&gt;&amp;1, 1&gt;&amp;2 等</a></p>

<p><a href="https://github.com/ahui132/ahui132.github.io/blob/master/_posts/linux-forkExec.md">exec的重定向 - GitHub</a></p>

<p><a href="http://www.cnblogs.com/chengmo/archive/2010/10/21/1856577.html">linux shell 管道命令(pipe)使用及与shell重定向区别</a></p>
<h1 id="数据类型">数据类型</h1>
<h2 id="1数值">1.数值</h2>
<h2 id="2字符串">2.字符串</h2>
<p>字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似</p>
<h3 id="21单引号">2.1单引号</h3>
<p>单引号的特点：</p>
<ul>
  <li>单引号里的任何字符都会<strong>原样输出</strong>，单引号字符串中的变量是无效的；</li>
  <li>单引号字串中不能出现单引号（<strong>对单引号使用转义符后也不行</strong>）
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[chen@localhost tmp]$ echo 'hello$val'
hello$val
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="22双引号">2.2双引号</h3>
<p>双引号的优点：</p>
<ul>
  <li>双引号里可以有变量</li>
  <li>双引号里可以出现<strong>转义字符</strong>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[chen@localhost tmp]$ echo "${val}hello\'"
1hello\'
</code></pre></div>    </div>
    <p>字符串更多操作，见下面的 运算/2字符串运算</p>
  </li>
</ul>

<h1 id="变量数组">变量&amp;数组</h1>
<h2 id="1变量">1.变量</h2>
<h3 id="11定义使用">1.1定义，使用</h3>
<ul>
  <li>变量的定义不加<code class="highlighter-rouge">$</code></li>
  <li><strong>不加<code class="highlighter-rouge">$</code>表示变量本身，可以<code class="highlighter-rouge">val++</code>，加<code class="highlighter-rouge">$</code>表示变量存储的值<code class="highlighter-rouge">val=$val+1</code></strong></li>
  <li><code class="highlighter-rouge">val=anything</code> <strong>等号两侧不能有空格</strong>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ubuntu@VM-10-194-ubuntu:/tmp$ VAR="some"
ubuntu@VM-10-194-ubuntu:/tmp$ NUM=123
# 注意:等号两侧不能有空格！ 变量名称全部用大写是编程惯例
ubuntu@VM-10-194-ubuntu:/tmp$ echo VAR
VAR
ubuntu@VM-10-194-ubuntu:/tmp$ echo $VAR
some
# 调用变量要加 $
[chen@localhost tmp]$ $val=hello
-bash: 1=hello: command not found
#$val表示变量存储的值，不能作为左值
#=左右有空格时报错
cndaqiang@girl:~/code/cndaqiang.github.io$ a = b
a: command not found
cndaqiang@girl:~/code/cndaqiang.github.io$ a= b
b: command not found
cndaqiang@girl:~/code/cndaqiang.github.io$ a=b
cndaqiang@girl:~/code/cndaqiang.github.io$ 
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="12只读变量">1.2只读变量</h3>
<p><strong>格式 readonly val</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[chen@localhost tmp]$ val=hello
[chen@localhost tmp]$ readonly val
[chen@localhost tmp]$ val=1
-bash: val: readonly variable
</code></pre></div></div>
<h3 id="13删除变量">1.3删除变量</h3>
<p><strong>格式 <code class="highlighter-rouge">unset val</code></strong></p>
<h3 id="14变量类型">1.4变量类型</h3>
<p>运行shell时，会同时存在三种变量：</p>
<ul>
  <li><strong>局部变量</strong> 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li>
  <li><strong>环境变量</strong> 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li>
  <li><strong>shell变量</strong> shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li>
</ul>

<h2 id="2数组">2.数组</h2>
<h3 id="21定义使用">2.1定义，使用</h3>
<p><strong>定义 <code class="highlighter-rouge">数组名=(值1 值2 ... 值n)</code> 或者 <code class="highlighter-rouge">数组名[下标]=值</code></strong></p>

<p><strong>使用 <code class="highlighter-rouge">${数组名[下标]}</code></strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#创建 a=( )
ubuntu@VM-10-194-ubuntu:/tmp$ a=(1 2 3 f g)
ubuntu@VM-10-194-ubuntu:/tmp$ echo $a
1
#显示所有元素或者echo ${a[*]}    {}表示内部是一个整体，也可以 ${val},传入参数$10时也要${10}
ubuntu@VM-10-194-ubuntu:/tmp$ echo ${a[@]}
1 2 3 f g
#显示数组元素，0代表第1个元素
ubuntu@VM-10-194-ubuntu:/tmp$ echo ${a[2]}   
3
ubuntu@VM-10-194-ubuntu:/tmp$ a["sth"]=TT  #这样也行
ubuntu@VM-10-194-ubuntu:/tmp$ echo ${a[@]} 
TT 2 3 f g
#或者逐个创建
ubuntu@VM-10-194-ubuntu:/tmp$ a[6]=100
ubuntu@VM-10-194-ubuntu:/tmp$ echo ${a[@]}
TT 2 3 f g 100
#显示数组元素删除a[2]的值，并不删除a[2]
ubuntu@VM-10-194-ubuntu:/tmp$ unset a[2]   
ubuntu@VM-10-194-ubuntu:/tmp$ echo ${a[2]}

ubuntu@VM-10-194-ubuntu:/tmp$ unset a   #删除数组a所有元素
#${数组名[@或*]:起始位置:长度} 输出数组的第1-3项
ubuntu@VM-10-194-ubuntu:/tmp$ echo ${a[@]:0:3}
#${数组名[@或*]/查找字符/替换字符   替换输出，并不改变数组
ubuntu@VM-10-194-ubuntu:/tmp$ echo ${a[*]/1/6}
</code></pre></div></div>

<h3 id="22获取数组长度">2.2获取数组长度</h3>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 取得数组元素的个数
length=${#array_name[@]}
# 或者
length=${#array_name[*]}
# 取得数组单个元素的长度
lengthn=${#array_name[n]}
</code></pre></div></div>

<h2 id="3-字典">3 字典</h2>
<p>示例</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>declare -A CarOrFrac
CarOrFrac["c"]="ScaledCartesian"
CarOrFrac["C"]="ScaledCartesian"
CarOrFrac["d"]="Fractional"
CarOrFrac["D"]="Fractional"
</code></pre></div></div>
<p>应用-构建key为元素符号，value为原子序数的字典</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>declare -A SpeciesOrder
Species=( H       He      Li      Be      B       C       N       O       F       Ne      Na      Mg      Al      Si
P       S       Cl      Ar      K       Ca      Sc      Ti      V       Cr      Mn      Fe      Co      Ni
Cu      Zn      Ga      Ge      As      Se      Br      Kr      Rb      Sr      Y       Zr      Nb      Mo
Tc      Ru      Rh      Pd      Ag      Cd      In      Sn      Sb      Te      I       Xe      Cs      Ba
La      Ce      Pr      Nd      Pm      Sm      Eu      Gd      Tb      Dy      Ho      Er      Tm      Yb
Lu      Hf      Ta      W       Re      Os      Ir      Pt      Au      Hg      Tl      Pb      Bi      Po
At      Rn      Fr      Ra      Ac      Th      Pa      U       Np      Pu      Am      Cm      Bk      Cf
Es      Fm      Md      No      Lr)
Order=1
for i in ${Species[@]}
do
SpeciesOrder[$i]=$Order
((Order++))
done
</code></pre></div></div>

<h1 id="bash文件">bash文件</h1>
<p><strong>1. 创建文件</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ubuntu@VM-10-194-ubuntu:/tmp$ &gt; test.sh
ubuntu@VM-10-194-ubuntu:/tmp$ touch test2.sh
ubuntu@VM-10-194-ubuntu:/tmp$ echo "something" &gt;test3.sh
ubuntu@VM-10-194-ubuntu:/tmp$ cat test3.sh 
something
</code></pre></div></div>
<p>创建多行,使用了重定向的知识，重定向见本文后段</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ubuntu@VM-10-194-ubuntu:/tmp$ cat &gt;test4.sh&lt;&lt;EOF
&gt; some
&gt; shu wan zhi jie hui che
&gt; zi dong tian jia &gt;
&gt; EOF
#EOF为任意字符串
ubuntu@VM-10-194-ubuntu:/tmp$ cat test4.sh 
some
shu wan zhi jie hui che
zi dong tian jia &gt;
</code></pre></div></div>
<p>不过还是喜欢，vi file 直接输入</p>

<p><strong>2. 添加执行权限</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ chmod +x test.sh 
</code></pre></div></div>
<p><strong>3. 编写脚本</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nb">echo</span> <span class="s2">"hello bash"</span>
<span class="nb">exit </span>0
</code></pre></div></div>
<blockquote>
  <p>说明：
<code class="highlighter-rouge"><span class="c">#!/bin/bash</span></code> : 它是bash文件声明语句，表示是以<code class="highlighter-rouge">/bin/bash</code>程序执行该文件。它必须写在文件的第一行！</p>

  <p><code class="highlighter-rouge">echo "hello bash"</code> : 表示在终端输出<code class="highlighter-rouge">hello bash</code></p>

  <p><code class="highlighter-rouge">exit 0</code> : 表示返回0。在bash中，0表示执行成功，其他表示失败。</p>
</blockquote>

<p><strong>4. 执行</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ubuntu@VM-10-194-ubuntu:/tmp$ ./test.sh 
hello bash
</code></pre></div></div>
<h1 id="注释">注释</h1>
<ul>
  <li>单行注释 以<code class="highlighter-rouge">#</code>开头的行就是注释</li>
  <li>多行注释 sh里没有多行注释，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果</li>
</ul>

<p>例</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>zhushi()
{
zhushi注释内容
echo zhushi
}
:||{
被注释的多行内容
}
</code></pre></div></div>

<h1 id="运算">运算</h1>
<h2 id="1-数值运算">1 数值运算</h2>
<p>数值元算主要有4种实现方式：<code class="highlighter-rouge">(())、let、expr、bc</code>。
工作效率：
<strong><code class="highlighter-rouge">(()) == let &gt; expr &gt; bc</code></strong></p>
<ul>
  <li><strong><code class="highlighter-rouge">(())</code>和<code class="highlighter-rouge">let</code>是bash内建命令，执行效率高,支持<code class="highlighter-rouge">i++</code></strong>；而<code class="highlighter-rouge">expr</code>和<code class="highlighter-rouge">bc</code>是系统命令，会消耗内存，执行效率低。</li>
  <li><strong>只有<code class="highlighter-rouge">bc</code>支持浮点运算</strong></li>
  <li><code class="highlighter-rouge">(())</code>内只能写整数计算的公式，写小数会报错</li>
</ul>

<p>例</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c">#!/bin/bash</span>
<span class="c">#(())  要加个$再赋予变量</span>
<span class="nv">val</span><span class="o">=</span><span class="k">$((</span><span class="m">3</span><span class="o">*(</span><span class="m">5</span><span class="o">+</span><span class="m">2</span><span class="k">))</span><span class="o">)</span>
<span class="nb">echo</span> <span class="nv">$val</span>

<span class="c">#let</span>
<span class="nb">let</span> <span class="s2">"val=3*(5+2)"</span>
<span class="nb">echo</span> <span class="nv">$val</span>

<span class="c">#expr 又费劲  注意是`重音符  ``输出命令结果，例如val=`ls`,val=`date`</span>
<span class="c">#还得用空格隔开运算符和数字，不然显示不对</span>
<span class="nv">val</span><span class="o">=</span><span class="sb">`</span><span class="nb">expr </span>3 <span class="se">\*</span> <span class="se">\(</span> 5 + 2 <span class="se">\)</span><span class="sb">`</span>
<span class="nb">echo</span> <span class="nv">$val</span>

<span class="c">#bc 是重音符`</span>
<span class="nv">val</span><span class="o">=</span><span class="sb">`</span><span class="nb">echo</span> <span class="s2">"3*(5+2)"</span>|bc<span class="sb">`</span>
<span class="nb">echo</span> <span class="nv">$val</span>
</code></pre></div></div>
<p><strong>使用<code class="highlighter-rouge">$(())</code>或<code class="highlighter-rouge">let</code>来进行整数计算，<code class="highlighter-rouge">bc</code>进行浮点数计算</strong></p>

<p><code class="highlighter-rouge">$(( 3+3 ))</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i++ ((val++))或者 let val++
</code></pre></div></div>
<p>例：bc精度计算,bc默认精度小数点后0位，使用<code class="highlighter-rouge">scale</code>设置</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SE=$(echo "scale=7;(1/2*($ssenergy-$j*$Ebulk)+($sfenergy-$ssenergy))/${S[i]}" | bc)
</code></pre></div></div>
<p>错误示例</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ val=$((3.00*(5+2)+$val))
-bash: 3.00*(5+2)+42：语法错误: 无效的算术运算符 (错误符号是 ".00*(5+2)+42")
 $ val=$((3*(5+2)+$val))
</code></pre></div></div>

<h2 id="2-字符串运算">2 字符串运算</h2>
<h2 id="21字符串的使用">2.1字符串的使用</h2>

<p><img src="http://upload-images.jianshu.io/upload_images/4575564-dfe8e1ec1d38da4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /></p>

<p>例</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ubuntu@VM-10-194-ubuntu:/tmp$ str="hello world"
ubuntu@VM-10-194-ubuntu:/tmp$ echo ${str}
hello world
ubuntu@VM-10-194-ubuntu:/tmp$ echo ${strq:?ERR_MSG}
-bash: strq: ERR_MSG
</code></pre></div></div>

<h2 id="22-字符串操作">2.2 字符串操作</h2>

<p><img src="http://upload-images.jianshu.io/upload_images/4575564-d66782aa065c7202.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" />
例</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ubuntu@VM-10-194-ubuntu:/tmp$ echo ${#str}
11
ubuntu@VM-10-194-ubuntu:/tmp$ echo ${str:3:6}
lo wor
ubuntu@VM-10-194-ubuntu:/tmp$ echo ${str%ld}
hello wor
#并不影响原字符串
ubuntu@VM-10-194-ubuntu:/tmp$ echo ${str}
hello world

</code></pre></div></div>

<h1 id="流程控制判断循环">流程控制(判断循环)</h1>
<h2 id="1-条件判断">1 条件判断</h2>
<h3 id="11-test">1.1 <strong>test</strong></h3>
<p><strong>语法</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test EXPRESSION
</code></pre></div></div>
<p>test是关键字，表示判断；
EXPRESSION是被判断的语句。</p>

<p><strong>1.1 数值判断</strong></p>

<table>
  <thead>
    <tr>
      <th>参数</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>-eq或 ==</td>
      <td>等于则为真</td>
    </tr>
    <tr>
      <td>-ne	或!=</td>
      <td>不等于则为真</td>
    </tr>
    <tr>
      <td>-gt	或&gt;</td>
      <td>大于则为真</td>
    </tr>
    <tr>
      <td>-ge	或&gt;=</td>
      <td>大于等于则为真</td>
    </tr>
    <tr>
      <td>-lt	或&lt;</td>
      <td>小于则为真</td>
    </tr>
    <tr>
      <td>-le	或&lt;=</td>
      <td>小于等于则为真</td>
    </tr>
  </tbody>
</table>

<p>使用&gt;=和&lt;=时,两边的数值和判断算符不要有空格</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[chen@localhost tmp]$ test 12 -eq 2
[chen@localhost tmp]$ echo $?
1
# $?表示上一命令的执行结果(在linux中bash中，*true返回0,false返回1*
</code></pre></div></div>

<p><strong>1.2字符串测试</strong></p>

<table>
  <thead>
    <tr>
      <th>参数</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>=</td>
      <td>等于则为真</td>
    </tr>
    <tr>
      <td>!=</td>
      <td>不相等则为真</td>
    </tr>
    <tr>
      <td>-z</td>
      <td>字符串	字符串的长度为零则为真</td>
    </tr>
    <tr>
      <td>-n</td>
      <td>字符串	字符串的长度不为零则为真</td>
    </tr>
  </tbody>
</table>

<p>例</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[chen@localhost tmp]$ test "hello" != "yes"
[chen@localhost tmp]$ echo $?
0
</code></pre></div></div>

<p><strong>1.3文件测试</strong></p>

<p><strong>linux文件</strong>:目录、链接、设备、文本。。。</p>

<table>
  <thead>
    <tr>
      <th>参数</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>-e 文件名</td>
      <td>如果文件存在则为真</td>
    </tr>
    <tr>
      <td>-r 文件名</td>
      <td>如果文件存在且可读则为真</td>
    </tr>
    <tr>
      <td>-w 文件名</td>
      <td>如果文件存在且可写则为真</td>
    </tr>
    <tr>
      <td>-x 文件名</td>
      <td>如果文件存在且可执行则为真</td>
    </tr>
    <tr>
      <td>-s 文件名</td>
      <td>如果文件存在且至少有一个字符则为真即文件长度大于0、非空</td>
    </tr>
    <tr>
      <td>-d 文件名</td>
      <td>如果文件存在且为目录则为真</td>
    </tr>
    <tr>
      <td>-f 文件名</td>
      <td>如果文件存在且为普通文件则为真</td>
    </tr>
    <tr>
      <td>-L 文件名</td>
      <td>如果文件存在且为符号连接</td>
    </tr>
    <tr>
      <td>-c 文件名</td>
      <td>如果文件存在且为字符型特殊文件则为真</td>
    </tr>
    <tr>
      <td>-b 文件名</td>
      <td>如果文件存在且为块特殊文件则为真</td>
    </tr>
    <tr>
      <td>-u 文件名</td>
      <td>如果文件存在且有suid位设置</td>
    </tr>
  </tbody>
</table>

<p>例</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ubuntu@VM-10-194-ubuntu:/tmp$ test -f ./123.txt 
ubuntu@VM-10-194-ubuntu:/tmp$ echo $?
0
</code></pre></div></div>
<h3 id="12-条件判断">1.2 <code class="highlighter-rouge">[]</code>条件判断</h3>
<p><strong>语法</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ EXPRESSION ]
</code></pre></div></div>
<p><strong>中括号的左右扩弧和EXPRESSION之间都必须有空格</strong>
<br /><strong>空格空格</strong>
<br />关于EXPRESSION的说明，参考如下：</p>

<p><img src="http://upload-images.jianshu.io/upload_images/4575564-b59f194eae7a007c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /></p>

<p>例</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ubuntu@VM-10-194-ubuntu:/tmp$ [ -f test2.sh ]
ubuntu@VM-10-194-ubuntu:/tmp$ echo $?
0
ubuntu@VM-10-194-ubuntu:/tmp$ [ -f test2.s11h ]
ubuntu@VM-10-194-ubuntu:/tmp$ echo $?
1
</code></pre></div></div>
<h3 id="13-逻辑">1.3 逻辑</h3>
<p>基本格式（上表也有）</p>

<p><code class="highlighter-rouge">-a</code> : 逻辑与,操作符两边均为真,结果为真,否则为假。</p>

<p><code class="highlighter-rouge">-o</code> : 逻辑或,操作符两边一边为真,结果为真,否则为假。</p>

<p><code class="highlighter-rouge">! </code>: 逻辑否,条件为假,结果为真。</p>

<p><code class="highlighter-rouge">[  expre ] &amp;&amp; [ expre2 ]</code>   与</p>

<p><code class="highlighter-rouge">[  expre ] || [ expre2 ] </code>   或</p>

<p>例</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#判断test2.sh是否可读写
[ -r test2.sh -a -w test2.sh ]
</code></pre></div></div>
<h2 id="2-if----then-cmd-elif------then-cmd---else-cmd--fi">2 <code class="highlighter-rouge">if [ ] ; then cmd; elif  [ ] ;  then cmd ;  else cmd ; fi</code></h2>
<p>if 或者 elif 后面必须有then，else直接跟命令，可以没有，最后以fi结尾</p>

<p>在bash文件中，回车，不需要分号，单行if命令需要分号</p>

<p>if后面<code class="highlighter-rouge">[]</code>的判断内容可为 test、[]判断，计算式(( ))等，以下涉及判断条件同理</p>

<p>例1</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> if [ 1 -eq 2 ] 
&gt; then echo 1==2
&gt; elif [ 2 -eq 3 ]
&gt; then 2==3
&gt; elif [ 3 -eq 4 ]
&gt; then echo 3==4
&gt; else echo 1=1 
&gt; fi
#或者
if [ 1 -eq 2 ] ; then echo 1==2; elif [ 2 -eq 3 ]; then 2==3; elif [ 3 -eq 4 ]; then echo 3==4; else echo 1==1; fi
1==1
</code></pre></div></div>
<p>例2</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="c"># 提示用户输入一个值</span>
<span class="nb">echo</span> <span class="nt">-n</span> <span class="s2">"please input a number:"</span>
<span class="c"># 保存用户的输入到num中</span>
<span class="nb">read </span>NUM
<span class="k">if</span> <span class="o">[</span> <span class="nv">$NUM</span> <span class="nt">-le</span> 5 <span class="o">]</span> <span class="p">;</span>
<span class="k">then </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$NUM</span><span class="s2">&lt;5"</span><span class="p">;</span>
<span class="k">else </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$NUM</span><span class="s2">&gt;5"</span><span class="p">;</span>
<span class="c">#分号可有可无</span>
<span class="k">fi
</span><span class="nb">exit </span>0
</code></pre></div></div>
<p>例3，判断字符串相等</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i in $(ls); do what=$(tail -1 $i); EF=EF;if [ "$what" != "$EF" ] ;then echo -e "$i"; fi; done
</code></pre></div></div>
<h2 id="3-case">3 case</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 格式
case 值 in
模式1)
命令1
...
;;
模式2)
命令2
...
;;
esac
</code></pre></div></div>
<p>例</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nb">echo</span> <span class="nt">-n</span> <span class="s2">"are you femail(Y/N)"</span>
<span class="nb">read </span>val
<span class="k">case</span> <span class="nv">$val</span> <span class="k">in
</span>Y|y<span class="p">)</span>
<span class="nb">echo</span> <span class="s2">"yes"</span>
<span class="p">;;</span>    <span class="c"># 注意此处有两个;</span>
N|n<span class="p">)</span>
<span class="nb">echo</span> <span class="s2">"no"</span>
<span class="p">;;</span>
<span class="k">*</span><span class="p">)</span>
<span class="nb">echo</span> <span class="s2">"incorrect input"</span>
<span class="p">;;</span>
<span class="k">esac</span>      <span class="c"># 注意esac结束</span>
<span class="nb">exit </span>0
</code></pre></div></div>
<h2 id="4-for循环">4 for循环</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for 变量名in列表  或者 for  ((i=1;i&lt;7;i++))，**注意两个括号**
do
命令1
命令2...
done
</code></pre></div></div>
<p>例</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ N=(1 2 3)
$ for i in ${N[@]}; do echo $i; done
1
2
3
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 判断当前目录下的文件并输出文件名
#!/bin/bash
#将ls结果保存到变量CUR，
CUR=`ls`    #注意这里是Tab键上面的`
# 大部分Unix shell以及编程语言如Perl、PHP以及Ruby等都以成对的重音符作指令替代，意思是以
某一个指令的输出结果作为另一个指令的输入项。例如上述指令
echo $CUR
for val in $CUR
do     #do不可少
if [ -f $val ] ;
then  echo "FILE: $val" ;
fi
done   #done 不可少
exit 0
</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#计算10以内数的和
#!/bin/bash
sum=0
for ((i=1;i&lt;10;i++))
do
((sum=$sum+$i))
# (( ))表示数值计算
done
echo "sum=$sum"
exit 0
</code></pre></div></div>
<h2 id="5-until">5 until</h2>
<p>循环至少运行一次
<strong>当满足条件时不再执行直接结束</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>until 条件
do
命令1
...
done
</code></pre></div></div>
<p>例;输出5以内的自然数</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nv">val</span><span class="o">=</span>0
<span class="k">until</span> <span class="o">((</span><span class="nv">$val</span><span class="o">==</span>5<span class="o">))</span>   <span class="c">#或者[ "$val" -eq "5" ] </span>
<span class="k">do
</span><span class="nb">echo</span> <span class="nv">$val</span>
<span class="o">((</span>val++<span class="o">))</span>
<span class="k">done
</span><span class="nb">exit </span>0
</code></pre></div></div>
<h2 id="6-while">6 while</h2>
<p><strong>满足条件才进行循环，最少不运行</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while 命令
do
命令1
命令2
...
done
</code></pre></div></div>
<p>例;输出5以内的自然数</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nv">val</span><span class="o">=</span>0
<span class="k">while</span> <span class="o">((</span>val&lt;5<span class="o">))</span>
<span class="k">do
</span><span class="nb">echo</span> <span class="nv">$val</span>
<span class="o">((</span><span class="nv">val</span><span class="o">=</span><span class="nv">$val</span>+1<span class="o">))</span>
<span class="k">done
</span><span class="nb">exit </span>0
</code></pre></div></div>
<h2 id="7-break-与continue">7 break 与continue</h2>
<p><strong>break命令允许跳出循环—–结束 
<br />continue命令跳过这个循环步—–进入下个循环</strong></p>

<p>例break输出5内自然数</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nv">val</span><span class="o">=</span>0
<span class="k">while </span><span class="nb">true
</span><span class="k">do
if</span> <span class="o">((</span><span class="nv">$val</span><span class="o">==</span>5<span class="o">))</span><span class="p">;</span>
<span class="k">then </span><span class="nb">break</span><span class="p">;</span>
<span class="k">fi
</span><span class="nb">echo</span> <span class="nv">$val</span>
<span class="o">((</span>val++<span class="o">))</span>
<span class="k">done
</span><span class="nb">exit </span>0
</code></pre></div></div>
<p>例:从0开始逐步递增到10：当数值为5时，将数值递增2；否则，输出数值</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nv">val</span><span class="o">=</span>0
<span class="k">while</span> <span class="o">((</span><span class="nv">$val</span>&lt;<span class="o">=</span>10<span class="o">))</span>
<span class="k">do
if</span> <span class="o">((</span><span class="nv">$val</span><span class="o">==</span>5<span class="o">))</span>   <span class="c">#好像没有；用&lt;Enter&gt;也是可以的</span>
<span class="k">then</span> <span class="o">((</span><span class="nv">val</span><span class="o">=</span><span class="nv">$val</span>+2<span class="o">))</span>
<span class="k">continue
else
</span><span class="nb">echo</span> <span class="nv">$val</span> 
<span class="o">((</span>val++<span class="o">))</span>
<span class="k">fi
done
</span><span class="nb">exit </span>0
</code></pre></div></div>

<h1 id="函数">函数</h1>
<p><strong>所有函数在使用前必须定义</strong>。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可</p>
<h2 id="1-定义">1 定义</h2>
<p>基本格式</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function 函数名()
{
...
return 返回值；
}
</code></pre></div></div>
<ul>
  <li>function可有可无。但建议保留，因为保留的话看起来更加直观</li>
  <li>return 返回值，如果不加，将以最后一条命令运行结果，作为返回值
例
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="k">function </span>foo<span class="o">()</span>
<span class="o">{</span>
<span class="nb">echo</span> <span class="s2">"hello"</span>
<span class="k">return </span>5<span class="p">;</span>
<span class="o">}</span>
foo
<span class="nb">echo</span> <span class="nv">$?</span>
<span class="c">#直接编写foo函数文件，在终端中运行foo“返回值为0”，没有echo结果</span>
</code></pre></div>    </div>
    <p>结果</p>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[chen@localhost tmp]$ ./han
hello
5
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="2-传递参数">2 传递参数</h2>
<p><strong><code class="highlighter-rouge">$n</code>代表输入的第n个参数</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foo param1 param2 param3
#参数变量出入函数内部为@ 例
echo $@
#输出结果为
param1 param2 param3
</code></pre></div></div>
<p>表格内容来自<a href="http://www.runoob.com/linux/linux-shell-passing-arguments.html">Shell 传递参数</a></p>

<table>
  <thead>
    <tr>
      <th>参数</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">$?</code></td>
      <td>显示上一条命令的退出状态。判断退出true为0,flase为1，函数退出结果为返回值,例<br /><code class="highlighter-rouge">[chen@localhost tmp]$ ((1+1))</code><br /><code class="highlighter-rouge">[chen@localhost tmp]$ echo $?</code><br /><code class="highlighter-rouge">0</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">$#</code></td>
      <td>传递到脚本的参数个数</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">$n</code></td>
      <td>表示传入的第n个参数<br /><strong><code class="highlighter-rouge">$10</code> 不能获取第十个参数，获取第十个参数需要<code class="highlighter-rouge">${10}</code>。当n&gt;=10时，需要使用<code class="highlighter-rouge">${n}</code>来获取参数</strong></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">$*</code></td>
      <td>以一个单字符串显示所有向脚本传递的参数。如<code class="highlighter-rouge">"$*"</code>用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">$@</code></td>
      <td>与<code class="highlighter-rouge">$*</code>相同，但是使用时加引号，并在引号中返回每个参数。如<code class="highlighter-rouge">$@</code>用「”」括起来的情况、以<code class="highlighter-rouge">$1</code> <code class="highlighter-rouge">$2</code> … <code class="highlighter-rouge">$n</code> 的形式输出所有参数。</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">$-</code></td>
      <td>显示Shell使用的当前选项，与<a href="http://www.runoob.com/linux/linux-comm-set.html">set命令</a>功能相同。</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">$$</code></td>
      <td>脚本运行的当前进程ID号</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">$!</code></td>
      <td>后台运行的最后一个进程的ID号</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">$0</code></td>
      <td>当前sehll名 <code class="highlighter-rouge">[chen@localhost tmp]$ echo $0</code> 结果为<code class="highlighter-rouge">bash</code></td>
    </tr>
  </tbody>
</table>

<p>** <code class="highlighter-rouge">$*</code> 和 <code class="highlighter-rouge">$@</code> 的区别**</p>
<blockquote>
  <ul>
    <li><code class="highlighter-rouge">$*</code> 和 <code class="highlighter-rouge">$@</code> <strong>都</strong>表示<strong>传递给函数或脚本</strong>的所有参数，不被双引号(“ “)包含时，都以”<code class="highlighter-rouge">$1</code>” “<code class="highlighter-rouge">$2</code>” … “<code class="highlighter-rouge">$n</code>” 的形式输出所有参数。</li>
    <li>但是当它们被双引号(“ “)包含时，”<code class="highlighter-rouge">$*</code>” 会将所有的参数作为一个整体，以”<code class="highlighter-rouge">$1 $2 … $n</code>“的形式输出所有参数；”<code class="highlighter-rouge">$@</code>” 会将各个参数分开，以”<code class="highlighter-rouge">$1</code>” “<code class="highlighter-rouge">$2</code>” … “<code class="highlighter-rouge">$n</code>” 的形式输出所有参数。</li>
  </ul>
</blockquote>

<p>例</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="k">for </span>val <span class="k">in</span> <span class="s2">"</span><span class="nv">$*</span><span class="s2">"</span>
<span class="k">do </span><span class="nb">echo</span> <span class="nv">$val</span>
<span class="k">done
</span><span class="nb">echo</span> <span class="se">\"</span>
<span class="k">for </span>val <span class="k">in</span> <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span>
<span class="k">do </span><span class="nb">echo</span> <span class="nv">$val</span>
<span class="k">done
</span><span class="nb">exit </span>0
</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ubuntu@VM-10-194-ubuntu:/tmp$ ./can 1 2 3 4
1 2 3 4
"
1
2
3
4
</code></pre></div></div>

<h2 id="内建命令">内建命令</h2>
<h3 id="1-内建指令查看">1 内建指令查看</h3>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>基本格式
type cmd
格式说明
type是命令关键字，cmd表示查看的命令；若输出builtin，则该命令是bash的内建命令。
例如:
ubuntu@VM-10-194-ubuntu:/tmp$ type echo
echo is a shell builtin
除此之外，用户也可以通过man bash或者man builtins查看bash的全部内置命令
</code></pre></div></div>
<h3 id="2-常用内建命令">2 常用内建命令</h3>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>（01）echo
命令：echo arg
功能：在屏幕上显示出由arg指定的字串
（02）read
命令格式：read变量名表
功能：从标准输入设备读入一行，分解成若干字，赋值给bash程序内部定义的变量
（03）shift
命令：shift [N] (N为大于0的整数；当N省略时，等价与于“shift 1”)
功能：所有的参数依次向左移动N个位置，并使用$#减少N，直到$#=0为止。
（04）alias
命令：alias name='value'
功能：别名。用name替换value，value要用单引号括住。
（05）export
命令：export变量名[=变量值]
功能：export可以把bash的变量向下带入子bash(即子bash中可以使用父bash的变量)，从而让子进程继承父进程中的环境变量。但子bash不能用export把它的变量向上带入父bash。
（06）readonly
命令：readonly 变量名
功能：定义只读变量。不带任何参数的readonly命令将显示出所有只读变量。
（07）exec
命令：exec 命令参数
功能：当bash执行到exec语句时，不会去创建新的子进程，而是转去执行指定的命令，当指定的命令执行完时，该进程（也就是最初的bash）就终止了，所以bash程序中exec后面的语句将不再 
被执行。
（08）"."(点)
命令：. bash程序文件名
功能：使bash读入指定的bash程序文件并依次执行文件中的所有语句。
（09）exit
命令：exit N
功能：退出Shell程序。在exit之后可有选择地指定一个数位作为返回状态。
</code></pre></div></div>
<h3 id="echo">echo</h3>
<ul>
  <li>echo是Shell的一个内部指令，用于在屏幕上打印出指定的字符串。命令格式</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>echo "anything"
"可有可无
</code></pre></div></div>

<ul>
  <li><strong>1 显示转义字符 backslash escapes</strong>
<br /><strong>在echo命令的帮助中，写到默认禁止反斜杠功能。如果需要开起反斜杠转义功能，需要使用-e的参数。</strong></li>
</ul>

<table>
  <thead>
    <tr>
      <th>转义字</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>\\</td>
      <td>反斜杠</td>
    </tr>
    <tr>
      <td>\a</td>
      <td>警报，响铃</td>
    </tr>
    <tr>
      <td>\b</td>
      <td>退格（删除键）</td>
    </tr>
    <tr>
      <td>\f</td>
      <td>换页(FF)，将当前位置移到下页开头</td>
    </tr>
    <tr>
      <td>\n</td>
      <td>换行</td>
    </tr>
    <tr>
      <td>\r</td>
      <td>回车</td>
    </tr>
    <tr>
      <td>\t</td>
      <td>水平制表符（tab键）</td>
    </tr>
    <tr>
      <td>\v</td>
      <td>垂直制表符</td>
    </tr>
  </tbody>
</table>

<p>例</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nb">echo</span> <span class="nt">-e</span>  <span class="s2">"hello</span><span class="se">\c</span><span class="s2">"</span>
<span class="nb">echo</span> <span class="s2">"hell</span><span class="se">\c</span><span class="s2">"</span>
<span class="nb">echo  </span>hell
<span class="nb">exit </span>0
</code></pre></div></div>
<p>结果</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hellohell\c
hell
</code></pre></div></div>
<p><strong>可看到，需要 -e 才能启用转义字符功能</strong>
对于 “ /需要// /” /$来输出，不适用上述规则</p>
<ul>
  <li><strong>2 显示变量</strong>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>echo $val
</code></pre></div>    </div>
    <p>当变量与其它字符相连时用{}隔开</p>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>echo ${val}-2-3 
</code></pre></div>    </div>
  </li>
  <li><strong>3 显示结果重定向至文件（写入另一个文件）</strong>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[chen@localhost tmp]$ echo rete &gt;file
[chen@localhost tmp]$ cat file
rete
</code></pre></div>    </div>
  </li>
  <li><strong>4 原样输出字符串</strong>
<strong>单引号</strong>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[chen@localhost tmp]$ echo '\$cal'
\$cal
</code></pre></div>    </div>
  </li>
  <li><strong>5 输出命令结果</strong>
<strong>重音符`</strong>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[chen@localhost tmp]$ echo `date`
Mon Aug 7 00:23:33 PDT 2017
</code></pre></div>    </div>
    <p><strong>双引号可有可无，单引号主要用在原样输出中，重音符输出命令</strong></p>
  </li>
</ul>

<h3 id="printf">printf</h3>
<blockquote>
  <p>printf 命令用于格式化输出， 是echo命令的增强版。它是C语言printf()库函数的一个有限的变形，并且在语法上有些不同。</p>

  <p>注意：printf 由 POSIX 标准所定义，移植性要比 echo 好。</p>
</blockquote>

<p><strong>格式</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>printf  format-string  [arguments...]
</code></pre></div></div>
<ul>
  <li>format-string 为格式控制字符串</li>
  <li>arguments 为参数列表</li>
</ul>

<p>例</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[chen@localhost tmp]$ printf "%d%s%c%f\n" 1 "abc" "def" "0.1"
1abcd0.100000
</code></pre></div></div>
<blockquote>
  <p>%d %s %c %f 格式替代符详解:
<br /> d：data 数字 – 对应位置参数必须是数字型，否则报错！
<br /> s：str 字符串 – 对应位置参数必须是字符串或者字符型，否则报错！
<br /> c：char 字符 – 对应位置参数必须是字符串或者字符型，否则报错！
<br /> f：float 浮点 – 对应位置参数必须是数字型，否则报错！
<br /> 如：上面第三个参数是 “def”，%c 自动截取字符串的第一个字符作为结果输出，若第四个参数无0.1则输出0.000000</p>
</blockquote>

<p><strong>指定输出宽度</strong>
<br />%-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐）
<br /><strong>默认转义</strong></p>

<table>
  <thead>
    <tr>
      <th>转义字符</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>\\</td>
      <td>反斜杠</td>
    </tr>
    <tr>
      <td>\a</td>
      <td>警报，响铃</td>
    </tr>
    <tr>
      <td>\b</td>
      <td>退格（删除键）</td>
    </tr>
    <tr>
      <td>\f</td>
      <td>换页(FF)，将当前位置移到下页开头</td>
    </tr>
    <tr>
      <td>\n</td>
      <td>换行</td>
    </tr>
    <tr>
      <td>\r</td>
      <td>回车</td>
    </tr>
    <tr>
      <td>\t</td>
      <td>水平制表符（tab键）</td>
    </tr>
    <tr>
      <td>\v</td>
      <td>垂直制表符</td>
    </tr>
    <tr>
      <td>\c</td>
      <td>抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</td>
    </tr>
    <tr>
      <td>\ddd</td>
      <td>表示1到3位数八进制值的字符。仅在格式字符串中有效</td>
    </tr>
    <tr>
      <td>\0ddd</td>
      <td>表示1到3位的八进制值字符</td>
    </tr>
  </tbody>
</table>

<p><strong>与C语言printf()函数的不同</strong></p>
<ul>
  <li>printf 命令不用加()</li>
  <li>format-string 可以没有引号，但最好加上，单引号双引号均可,不加上运行结果偶尔异常,如
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[chen@localhost tmp]$ printf "hello\n"
hello
[chen@localhost tmp]$ printf hello\n
hellon[chen@localhost tmp]$
</code></pre></div>    </div>
  </li>
  <li>参数多于格式控制符(%)时，format-string 可以重用，可以将所有参数都转换,即未指定格式使用前面的格式
例
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[chen@localhost tmp]$ printf "%s\n%s%s\n" 1 2 3
1
23
[chen@localhost tmp]$ printf "%s\n" 1 2 3    #格式不够使，借前面的格式
1
2
3
</code></pre></div>    </div>
  </li>
  <li>arguments 使用空格分隔，不用逗号。
例
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[chen@localhost tmp]$ printf "%s\n" 1,2 3  #逗号不分隔，空格分隔
1,2
3
</code></pre></div>    </div>
  </li>
</ul>

<h1 id="调试">调试</h1>
<h2 id="1-bash命令调试">1 bash命令调试</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash [-nvx] scripts.sh
</code></pre></div></div>
<p>选项与参数:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-n :不要执行 script,仅查询语法的问题;
-v :再执行 sccript 前,先将 scripts 的内容输出到屏幕上;
-x :将使用到的 script 内容显示到屏幕上,这是很有用的参数!
例如，想要执行bash脚本，并查看bash的调用流程，可以通过以下命令：
$ bash -x test.sh
</code></pre></div></div>
<h2 id="2-echo调试">2 echo调试</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>echo [OPTION] STRING
-n : 输出内容之后，不换行。默认是输入内容之后，换行。
-e : 开启反斜线“\”转义功能
-E : 关闭反斜线“\”转义功能（**默认**）。
例如，输出“please input a number:”之后不换行。
$ echo -n "please input a number:"
</code></pre></div></div>
<h2 id="3-printf">3 printf</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>和echo一样，printf也能用于输出。语法格式和C语言中printf一样。
例如，输出“hello printf”之后换行。
$ printf "hello printf\n"
</code></pre></div></div>
<p>#</p>

<h1 id="输入输出重定向">输入输出重定向</h1>
<p><strong>标准输入，标准输出，标准错误输出</strong>
<br />执行一个shell命令行时通常会自动打开三个标准文件，即</p>
<ul>
  <li>标准输入文件（stdin），即shell的输入设备(linux里设备也是文件)，通常对应终端的键盘；</li>
  <li>标准输出文件（stdout）为执行命令成功时将运行的结果输出到的文件</li>
  <li>标准错误输出到文件（stderr）为执行命令报错时将错误信息输出到的文件，这两个文件都对应终端的屏幕。</li>
</ul>

<p>在<code class="highlighter-rouge">/dev</code>下可以看到 <code class="highlighter-rouge">stdin stdout stderr</code>三个文件分别为标准输入，标准输出，标准错误输出,通过下面的例子可以看到 stdin stdout stderr分别连接到不同的文件</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ubuntu@VM-10-194-ubuntu:/dev$ ls -all std*
lrwxrwxrwx 1 root root 15 Aug  7 09:34 stderr -&gt; /proc/self/fd/2
lrwxrwxrwx 1 root root 15 Aug  7 09:34 stdin -&gt; /proc/self/fd/0
lrwxrwxrwx 1 root root 15 Aug  7 09:34 stdout -&gt; /proc/self/fd/1
</code></pre></div></div>
<p><strong>输入输出重定即: 改变输入/输出数据的的读取/输出的默认文件（键盘或终端）为其他文件（普通文件，文件描述符，文件设备）,而且只能是文件</strong></p>

<p><strong>常用操作符</strong></p>

<table>
  <thead>
    <tr>
      <th>名称</th>
      <th>默认文件描述符</th>
      <th>操作符</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>标准输入(stdin)</td>
      <td>0</td>
      <td>&lt; ,«,0&lt;或0«	 <br /> 0&lt;与&lt;等价，其他带有文件描述符的操作符意义同理，«代表追加</td>
    </tr>
    <tr>
      <td>标准输出(stdout)</td>
      <td>1</td>
      <td>&gt;, », 1&gt; 或 1»</td>
    </tr>
    <tr>
      <td>标准错误输出(stderr)</td>
      <td>2</td>
      <td>2&gt; 或 2»</td>
    </tr>
  </tbody>
</table>

<h2 id="输入重定向">输入重定向</h2>
<blockquote>
  <p>输入重定向是指把命令（或可执行程序）的标准输入重定向到指定的文件中。也就是说，输入可以不来自键盘，而来自一个指定的文件。所以说，输入重定向主要用于改变一个命令的输入源，特别是改变那些需要大量输入的输入源。</p>
</blockquote>

<p><strong>格式</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>命令 操作符 重定向文件
</code></pre></div></div>
<p>示例命令</p>

<table>
  <thead>
    <tr>
      <th>格式</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Command &lt; filename</td>
      <td>Command 命令以 filename 文件作为标准输入</td>
    </tr>
    <tr>
      <td>Command &lt; filename &gt; filename2</td>
      <td>Command 信不信以 filename 文件作为标准输入，以 filename 2  作为标准输出<br /><strong>注: 输入(&gt;或») 与 输出(&lt;或«)无强制顺序 即wc &gt;test«delim与wc «delim  &gt;test一样</strong></td>
    </tr>
    <tr>
      <td>Command « delimiter</td>
      <td>从标准输入中读入，以  delimiter(任意) 为结束符，祥见示例</td>
    </tr>
  </tbody>
</table>

<p><strong>注: 上表格中的重定向仅在当前命令生效</strong>
<br />例
wc 统计指定文件包含的行数、单词数和字符数</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#当只输入wc时，回等待用户输入，直至 ctrl+d停止，然后统计行数、单词数和字符数
ubuntu@VM-10-194-ubuntu:/tmp$ wc
123 34
23      1       3       9
# 也可将输入重定向为某个文件
ubuntu@VM-10-194-ubuntu:/tmp$ wc &lt; file
13 13 95
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ubuntu@VM-10-194-ubuntu:/tmp$ wc &lt;&lt;delim
&gt; haha
&gt; test
&gt; lala
&gt; delim
 3  3 15
#或者，将结果输出到test中
ubuntu@VM-10-194-ubuntu:/tmp$ wc &gt;test&lt;&lt;delim
&gt; haha
&gt; test
&gt; lala
&gt; delim
ubuntu@VM-10-194-ubuntu:/tmp$ cat test
 3  3 15
</code></pre></div></div>

<h2 id="输出重定向">输出重定向</h2>
<blockquote>
  <p>输出重定向是指把命令（或可执行程序）的标准输出或标准错误输出重新定向到指定文件中。这样，该命令的输出就不显示在屏幕上，而是写入到指定文件中。</p>

  <p>输出重定向比输入重定向更常用，很多情况下都可以使用这种功能。例如，如果某个命令的输出很多，在屏幕上不能完全显示，那么将输出重定向到一个文件中，然后 再用文本编辑器打开这个文件，就可以查看输出信息；如果想保存一个命令的输出，也可以使用这种方法。</p>
</blockquote>

<p><strong>格式</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>命令 操作符 重定向文件
</code></pre></div></div>

<p><strong>注意标准输出和标准错误输出不是”一个”文件</strong>，所以有两个输出，只改一个的话，另一个不变，同时改变需要<strong>2&gt;file  1&gt;file</strong>(意思是标准输出到file，标准错误输出到file)，或者<strong>&gt;file 2&gt;&amp;1</strong>(表示标准输出到file，标准错误输出到标准输出的文件即file)或者<strong>&amp;&gt;file</strong> (意思是把 标准输出 和 标准错误输出 都重定向到文件file中）
<br /><strong>»</strong>为追加输入，即在原文件内末尾添加
示例命令</p>

<table>
  <thead>
    <tr>
      <th>格式</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Command &gt; filename</td>
      <td>把标准输出重定向到一个新文件中</td>
    </tr>
    <tr>
      <td>Command » filename</td>
      <td>把标准输出重定向到一个文件(<strong>追加</strong>)</td>
    </tr>
    <tr>
      <td>Command 2&gt; filename</td>
      <td>把标准<strong>错误</strong>重定向到一个文件中</td>
    </tr>
    <tr>
      <td>Command 2» filename</td>
      <td>把标准<strong>错误</strong>重定向到一个文件中(追加)</td>
    </tr>
    <tr>
      <td>Command &gt; filename 2&gt;&amp;1</td>
      <td>把标准输出和错误<strong>一起</strong>重定向到一个文件中</td>
    </tr>
    <tr>
      <td>Command » filename 2&gt;&amp;1</td>
      <td>把标准输出和错误<strong>一起</strong>重定向到一个文件中(追加)</td>
    </tr>
  </tbody>
</table>

<p><strong>注: 上表格中的重定向仅在当前命令生效</strong>
<br />例</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ubuntu@VM-10-194-ubuntu:/tmp$ ls vv &gt;file
ubuntu@VM-10-194-ubuntu:/tmp$ ls vv &gt;&gt;file
ubuntu@VM-10-194-ubuntu:/tmp$ cat file
vv
vv
</code></pre></div></div>

<h2 id="绑定重定向">绑定重定向</h2>
<p>前两种重定向仅生效一次，绑定重定向即<strong>永久重定向</strong>输入输出文件，所有命令的输入输出都都来自重定向后的文件
<br /><strong>格式</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>exec 操作符 重定向文件
</code></pre></div></div>
<p>操作符 ` &lt;   0&lt;   «   &gt;   1&gt; ….` 与之前意义相同
例</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 将输出绑定重定向到/tmp/test后命令的结果不会输出到终端
ubuntu@VM-10-194-ubuntu:/tmp$ exec &gt;/tmp/test
ubuntu@VM-10-194-ubuntu:/tmp$ ls
ubuntu@VM-10-194-ubuntu:/tmp$ ls -11
# 将输出重定向回/dev/tty(注意必须写完整路径)则终端又输出命令运行结果
ubuntu@VM-10-194-ubuntu:/tmp$ exec &gt;/dev/tty
ubuntu@VM-10-194-ubuntu:/tmp$ ls
!  1  cal.sh  cancan  cvm_init.log  ff    net_affinity.log  sagent.pid  test  vv
0  2  can     chon    ec            file  pin               setRps.log  tty
</code></pre></div></div>

<h3 id="文件描述符">文件描述符</h3>
<p>文件描述符，可以理解为<strong>文件的一个数字标记</strong>
例</p>
<ul>
  <li>&amp;0代表标准输入文件的标记为0</li>
  <li>&amp;1 代表标准输出文件标记为1</li>
  <li>&amp;2代表标准错误输出</li>
  <li>&amp;-代表关闭与它绑定的描述符</li>
</ul>

<p>&amp;n 代表是已经存在的文件描述符，在重定向时与文件地位相同，即<strong>重定向的文件也可以用文件描述符来表示</strong></p>

<p><strong>格式</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#指定m描述的文件
命令 m&gt;file
#一般为一次性重定向，绑定重定向命令为exec，
# file也可以为&amp;n，这样m-&gt;n-&gt;n描述的文件
</code></pre></div></div>
<p>示例命令</p>

<table>
  <thead>
    <tr>
      <th>格式</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Command  &gt;&amp;n</td>
      <td>把标准输出重定向到文件描述符 n 中，如 ls &gt;&amp;1 ，<strong>若要实现绑定重定向则Command为exec如 exec &gt;&amp;n</strong></td>
    </tr>
    <tr>
      <td>Command m&gt;&amp;n</td>
      <td>把往文件描述符 m 的输出重定向到文件描述符 n 上，2&gt;&amp;1,<strong>若要实现绑定重定向则 exec m&gt;&amp;n</strong></td>
    </tr>
    <tr>
      <td>Command &lt;&amp;-</td>
      <td>关闭标准输入<strong>同样绑定则Command为exec</strong></td>
    </tr>
    <tr>
      <td>Command 2&gt;&amp;-</td>
      <td>关闭标准错误输出，和 2&gt;/dev/null 有类似功效,<strong>同样绑定则Command为exec</strong></td>
    </tr>
    <tr>
      <td>Command n&gt;&amp;-</td>
      <td>关闭输出文件描述符n，和 2&gt;/dev/null 有类似功效,<strong>同样绑定则Command为exec</strong></td>
    </tr>
  </tbody>
</table>

<p>例</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ubuntu@VM-10-194-ubuntu:/tmp$ exec 6&gt;&amp;1
#原理: 6 -&gt; 1 -&gt; stdout -&gt; /dev/tty
ubuntu@VM-10-194-ubuntu:/tmp$ exec 1&gt;test.txt
#原理: 1-&gt;test.txt 同时 stdout -&gt; test.txt
ubuntu@VM-10-194-ubuntu:/tmp$ ls
#原理: ls结果输出到/tmp/test.txt了
ubuntu@VM-10-194-ubuntu:/tmp$ exec 1&gt;&amp;6
#原理: 1-&gt; 6 -&gt; /dev/tty 同时 stdout -&gt; /dev/tty，也可直接exec 1&gt;/dev/tty或者 exec 1&gt;&amp;2
ubuntu@VM-10-194-ubuntu:/tmp$ ls
cvm_init.log  net_affinity.log  sagent.pid  setRps.log  test.txt
#原理: ls结果输出到/dev/tty即终端
ubuntu@VM-10-194-ubuntu:/tmp$ ls /dev/fd
0  1  2  3  6
#添加文件描述符后在/dev/fd里可以看到
ubuntu@VM-10-194-ubuntu:/tmp$ exec 6&gt;&amp;-
#
ubuntu@VM-10-194-ubuntu:/tmp$ ls /dev/fd
0  1  2  3

</code></pre></div></div>
<h2 id="备注">备注</h2>
<h4 id="1---n等操作符可以同时出现在一条命令里而且无顺序要求如">1. &gt; &lt; n&gt;等操作符可以同时出现在一条命令里，而且无顺序要求，如</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ubuntu@VM-10-194-ubuntu:/tmp$ exec 1&gt;test 2&gt;/dev/tty
</code></pre></div></div>
<h4 id="2-命令行前面这一条ubuntuvm-10-194-ubuntutmp以及输入的命令在键盘上的显示好像属于标准错误输出">2. 命令行前面这一条<code class="highlighter-rouge">ubuntu@VM-10-194-ubuntu:/tmp$</code>以及输入的命令在键盘上的显示好像属于标准错误输出</h4>
<h5 id="3--命令--文件-中的命令应该能接受标准输入-命令--文件中的命令应该有标准输出">3.  <code class="highlighter-rouge">命令 &lt; 文件</code> 中的命令应该能接受标准输入 ，<code class="highlighter-rouge">命令 &gt; 文件</code>中的命令应该有标准输出</h5>
<h4 id="4-在类unix系统中devnull或称空设备是一个特殊的设备文件它丢弃一切写入其中的数据但报告写入操作成功读取它则会立即得到一个eof可以重定向输出到devnull">4. 在类Unix系统中，<strong>/dev/null</strong>，或称<strong>空设备</strong>，是一个特殊的设备文件，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个EOF,可以重定向输出到/dev/null</h4>
<h1 id="其他传递">其他传递</h1>

<h3 id="管道">管道</h3>
<p>将一个程序或命令的输出作为另一个程序或命令的输入，有两种方法，一种是通过一个临时文件将两个命令或程序结合在一起，例如</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ubuntu@VM-10-194-ubuntu:/tmp$ ls &gt; test
ubuntu@VM-10-194-ubuntu:/tmp$ cat test
cvm_init.log
net_affinity.log
sagent.pid
setRps.log
test
</code></pre></div></div>
<p>另一种是Linux所提供的管道功能。</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ubuntu@VM-10-194-ubuntu:/tmp$ ls | cat
cvm_init.log
net_affinity.log
sagent.pid
setRps.log
test
</code></pre></div></div>
<p><strong>管道工作流程</strong></p>
<blockquote>
  <p><img src="http://upload-images.jianshu.io/upload_images/4575564-411d93bb87b5077a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" />
<br />command1正确输出，作为command2的输入 然后comand2的输出作为，comand3的输入 ，comand3输出就会直接显示在屏幕上面了。
<br />
通过管道之后：comand1,comand2的正确输出不显示在屏幕上面
<br />
注意：</p>
  <ol>
    <li>管道命令只处理前一个命令正确输出，<strong>不处理错误输出</strong></li>
    <li>管道命令右边命令，必须能够接收标准输入流命令才行</li>
  </ol>
</blockquote>

<p><strong>管道与重定向的区别</strong></p>
<blockquote>
  <ol>
    <li><strong>管道</strong>
<br />左边的命令应该有标准输出 <strong>|</strong> 右边的命令应该接受标准输入
<br />   <strong>重定向</strong> 
<br />   左边的命令应该有标准输出 <strong>&gt;</strong> 右边只能是文件
<br />   左边的命令应该需要标准输入 <strong>&lt;</strong> 右边只能是文件</li>
    <li>管道触发两个子进程执行<strong>|</strong>两边的程序；而重定向是在一个进程内执行
      <ul>
        <li><strong>重定向的优先级大于管道的优先级</strong></li>
      </ul>
    </li>
  </ol>
</blockquote>

<p>例<br />
来源:<a href="http://www.cnblogs.com/chengmo/archive/2010/10/21/1856577.html">linux shell 管道命令(pipe)使用及与shell重定向区别</a>
<br />例中的grep为正则表达时搜索，以及sed，awk命令以后有时间，继续学习做笔记</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#可以相互转换情况
#输入重定向
 
[chengmo@centos5 shell]$ cat test.sh| grep -n 'echo'
5:    echo "very good!";
7:    echo "good!";
9:    echo "pass!";
11:    echo "no pass!";
#"|"管道两边都必须是shell命令
 
 
[chengmo@centos5 shell]$ grep -n 'echo' &lt;test.sh    
5:    echo "very good!";
7:    echo "good!";
9:    echo "pass!";
11:    echo "no pass!";
#"重定向"符号，右边只能是文件（普通文件，文件描述符，文件设备）
 
 
[chengmo@centos5 shell]$ mail -s 'test' 8292669@qq.com &lt;test.sh
[chengmo@centos5 shell]$ cat test.sh|mail -s 'test' 8292669@qq.com
#以上2个也相同，将test.sh内容发送到指定邮箱。
 
 
[chengmo@centos5 shell]$ (sed -n '1,$p'|grep -n 'echo')&lt;test.sh 
5:    echo "very good!";
7:    echo "good!";
9:    echo "pass!";
11:    echo "no pass!";
#这个脚本比较有意思了。由于前面是管道，后面需要把test.sh内容重定向到 sed ，然后sed输出通过管道，输入给grep.需要将前面用"()"运算符括起来。在单括号内的命令，可以把它们看作一个象一个命令样。如果不加括号test.sh就是grep 的输入了。
 
 
#上面一个等同于这个
[chengmo@centos5 shell]$ sed -n '1,$p'&lt;test.sh | grep -n 'echo'
5:    echo "very good!";
7:    echo "good!";
9:    echo "pass!";
11:    echo "no pass!";
 
#重定向运算符，在shell命令解析前，首先检查的（一个命令，执行前一定检查好它的输入，输出，也就是0,1,2 设备是否准备好），所以优先级会最高
 
 
[chengmo@centos5 shell]$ sed -n '1,10p'&lt;test.sh | grep -n 'echo' &lt;testsh.sh
10:echo $total;
18:echo $total;
21:     echo "ok";
#哈哈，这个grep又接受管道输入，又有testsh.sh输入，那是不是2个都接收呢。刚才说了"&lt;"运算符会优先，管道还没有发送数据前，grep绑定了testsh.sh输入，这样sed命令输出就被抛弃了。这里一定要小心使用
 
#输出重定向
 
[chengmo@centos5 shell]$ cat test.sh&gt;test.txt
[chengmo@centos5 shell] cat test.sh|tee test.txt &amp;&gt;/dev/null
#通过管道实现将结果存入文件,还需要借助命令tee，它会把管道过来标准输入写入文件test.txt ,然后将标准输入复制到标准输出(stdout),所以重定向到/dev/null 不显示输出
#"&gt;"输出重定向，往往在命令最右边，接收左边命令的，输出结果，重定向到指定文件。也可以用到命令中间。
 
 
[chengmo@centos5 shell]$ ls test.sh test1.sh testsh.sh 2&gt;err.txt | grep 'test'
test.sh
testsh.sh
#目录下面有：test,testsh文件，test1.sh不存在，因此将ls 命令错误输出输入到err.txt 正确输出，还会通过管道发送到grep命令。
[chengmo@centos5 shell]$ ls test.sh test1.sh testsh.sh &amp;&gt;err.txt | grep 'test'
#这次打印结果是空，&amp;代表正确与错误输出 都输入给err.txt，通过管道继续往下面传递数据为空,所以没有什么显示的
 
#同样"&gt;"输出重定向符，优先级也是先解析，当一个命令有这个字符，它就会与左边命令标准输出绑定。准备好了这些，就等待命令执行输出数据，它就开始接收
</code></pre></div></div>

<h2 id="命令替换重音符">命令替换(重音符`)</h2>
<blockquote>
  <p>命令替换和重定向有些相似，但区别在于命令替换是将一个命令的输出作为另外一个命令的<strong>参数</strong></p>
</blockquote>

<p>而<strong>重定向必须为一个文件，而重音符``是将命令的结果作为参数传递</strong>例如</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ubuntu@VM-10-194-ubuntu:/tmp$ echo 192.168.1.1 &gt; file
# ping需要参数，不是文件，即不能接受标准输入，可以接受重音符运行的参数，不能接受重定向的输入文件
ubuntu@VM-10-194-ubuntu:/tmp$ ping `cat file`
PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data.
^Z
[8]+  Stopped                 ping `cat file`
ubuntu@VM-10-194-ubuntu:/tmp$ echo 192.168.1.1 &gt;file
ubuntu@VM-10-194-ubuntu:/tmp$ ping &lt; file
Usage: ping [-aAbBdDfhLnOqrRUvV]...省略
##cat 可以接收文件，也可以接受参数，即可以接受标准输入
ubuntu@VM-10-194-ubuntu:/tmp$ cat file
192.168.1.1
ubuntu@VM-10-194-ubuntu:/tmp$ cat &lt; file
192.168.1.1
ubuntu@VM-10-194-ubuntu:/tmp$ cat `echo file`
192.168.1.1
</code></pre></div></div>

<h1 id="有趣">有趣</h1>

<h2 id="多线程--与wait">多线程 <code class="highlighter-rouge">&amp; </code>与<code class="highlighter-rouge">wait</code></h2>
<p>参考<a href="https://blog.51cto.com/mochaming/1279864">该链接已失效</a></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="c">##################################</span>
<span class="c"># Author : cndaqiang             #</span>
<span class="c"># Update : 2019-09-02            #</span>
<span class="c"># Build  : 2019-04-11            #</span>
<span class="c"># What   : 并行：从代码中找特定字符函数/变量  #</span>
<span class="c">##################################</span>
<span class="k">for </span>i <span class="k">in</span> <span class="si">$(</span><span class="nb">ls</span><span class="si">)</span>
<span class="k">do
        </span><span class="nb">grep</span> <span class="nt">-rni</span> <span class="nv">$1</span> <span class="nv">$i</span> &amp;                                                                                
<span class="k">done
</span><span class="nb">wait</span>
</code></pre></div></div>
<p><img src="/uploads/2019/10/bashpa.png" alt="" /></p>

<h1 id="还有好多需要学的留在下篇继续">还有好多需要学的，留在下篇继续</h1>
:ET