I"¥™<ul id="markdown-toc">
  <li><a href="#å‚è€ƒ" id="markdown-toc-å‚è€ƒ">å‚è€ƒ</a></li>
  <li><a href="#æ³¨" id="markdown-toc-æ³¨">æ³¨</a></li>
  <li><a href="#å…¬å¼" id="markdown-toc-å…¬å¼">å…¬å¼</a></li>
  <li><a href="#ç›¸å…³æ–‡ä»¶" id="markdown-toc-ç›¸å…³æ–‡ä»¶">ç›¸å…³æ–‡ä»¶</a>    <ul>
      <li><a href="#è¯»å…¥èµåŠ¿" id="markdown-toc-è¯»å…¥èµåŠ¿">è¯»å…¥èµåŠ¿</a></li>
      <li><a href="#èµåŠ¿å®šä¹‰" id="markdown-toc-èµåŠ¿å®šä¹‰">èµåŠ¿å®šä¹‰</a></li>
    </ul>
  </li>
  <li><a href="#èµåŠ¿ç»“æ„ä½“å®šä¹‰" id="markdown-toc-èµåŠ¿ç»“æ„ä½“å®šä¹‰">èµåŠ¿ç»“æ„ä½“å®šä¹‰</a>    <ul>
      <li><a href="#åŸºæœ¬ä¿¡æ¯" id="markdown-toc-åŸºæœ¬ä¿¡æ¯">åŸºæœ¬ä¿¡æ¯</a></li>
      <li><a href="#wavefunctions-and-projectors" id="markdown-toc-wavefunctions-and-projectors">Wavefunctions and projectors</a></li>
      <li><a href="#minimal-radial-grid" id="markdown-toc-minimal-radial-grid">Minimal radial grid:</a></li>
      <li><a href="#pseudized-core-charge" id="markdown-toc-pseudized-core-charge">Pseudized core charge</a></li>
      <li><a href="#local-potential" id="markdown-toc-local-potential">Local potential</a></li>
      <li><a href="#augmentation" id="markdown-toc-augmentation">Augmentation</a></li>
      <li><a href="#wfc" id="markdown-toc-wfc">wfc</a></li>
      <li><a href="#soc" id="markdown-toc-soc">SOC</a></li>
      <li><a href="#paw" id="markdown-toc-paw">PAW:</a></li>
      <li><a href="#gipaw" id="markdown-toc-gipaw">GIPAW:</a></li>
      <li><a href="#md5" id="markdown-toc-md5">MD5</a></li>
    </ul>
  </li>
  <li><a href="#å…¶ä»–éœ€è¦çš„ç»“æ„ä½“" id="markdown-toc-å…¶ä»–éœ€è¦çš„ç»“æ„ä½“">å…¶ä»–éœ€è¦çš„ç»“æ„ä½“</a>    <ul>
      <li><a href="#radial_grid_type-ç»“æ„ä½“ä¿¡æ¯" id="markdown-toc-radial_grid_type-ç»“æ„ä½“ä¿¡æ¯">radial_grid_type ç»“æ„ä½“ä¿¡æ¯</a></li>
    </ul>
  </li>
  <li><a href="#ç›¸å…³å˜é‡" id="markdown-toc-ç›¸å…³å˜é‡">ç›¸å…³å˜é‡</a>    <ul>
      <li><a href="#module-uspp_param" id="markdown-toc-module-uspp_param"><code class="highlighter-rouge">MODULE uspp_param</code></a></li>
      <li><a href="#module-uspp" id="markdown-toc-module-uspp"><code class="highlighter-rouge">MODULE uspp</code></a></li>
    </ul>
  </li>
  <li><a href="#upfæ–‡ä»¶å†…å®¹" id="markdown-toc-upfæ–‡ä»¶å†…å®¹">UPFæ–‡ä»¶å†…å®¹</a>    <ul>
      <li><a href="#oncvpspèµåŠ¿ç»“æ„" id="markdown-toc-oncvpspèµåŠ¿ç»“æ„">ONCVPSPèµåŠ¿ç»“æ„</a></li>
    </ul>
  </li>
  <li><a href="#è¯»å…¥æµç¨‹" id="markdown-toc-è¯»å…¥æµç¨‹">è¯»å…¥æµç¨‹</a>    <ul>
      <li><a href="#readpp-èµåŠ¿è¯»å–å…¥å£" id="markdown-toc-readpp-èµåŠ¿è¯»å–å…¥å£">readpp èµåŠ¿è¯»å–å…¥å£</a>        <ul>
          <li><a href="#åŠŸèƒ½" id="markdown-toc-åŠŸèƒ½">åŠŸèƒ½</a></li>
          <li><a href="#å‚æ•°-readpp--input_dft-printout-ecutwfc_pp-ecutrho_pp-" id="markdown-toc-å‚æ•°-readpp--input_dft-printout-ecutwfc_pp-ecutrho_pp-">å‚æ•°: <code class="highlighter-rouge">readpp ( input_dft, printout, ecutwfc_pp, ecutrho_pp )</code></a></li>
        </ul>
      </li>
      <li><a href="#read_upf-upfèµåŠ¿è¯»å–å…¥å£" id="markdown-toc-read_upf-upfèµåŠ¿è¯»å–å…¥å£">read_upf UPFèµåŠ¿è¯»å–å…¥å£</a>        <ul>
          <li><a href="#åŠŸèƒ½-1" id="markdown-toc-åŠŸèƒ½-1">åŠŸèƒ½</a></li>
          <li><a href="#å‚æ•°-read_upfupf-grid-ierr-unit--filename" id="markdown-toc-å‚æ•°-read_upfupf-grid-ierr-unit--filename">å‚æ•°: <code class="highlighter-rouge">read_upf(upf, grid, ierr, unit,  filename)</code></a></li>
        </ul>
      </li>
      <li><a href="#read_upf_v2-ç›´æ¥è¯»å…¥v2ç‰ˆupfæ–‡ä»¶å¹¶è®¾ç½®å‚æ•°" id="markdown-toc-read_upf_v2-ç›´æ¥è¯»å…¥v2ç‰ˆupfæ–‡ä»¶å¹¶è®¾ç½®å‚æ•°">read_upf_v2 ç›´æ¥è¯»å…¥v2ç‰ˆUPFæ–‡ä»¶,å¹¶è®¾ç½®å‚æ•°</a>        <ul>
          <li><a href="#åŠŸèƒ½-2" id="markdown-toc-åŠŸèƒ½-2">åŠŸèƒ½</a></li>
          <li><a href="#å‚æ•°-read_upf_v2u-upf-grid-ierr-" id="markdown-toc-å‚æ•°-read_upf_v2u-upf-grid-ierr-">å‚æ•°: <code class="highlighter-rouge">read_upf_v2(u, upf, grid, ierr) </code></a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>QEä»£ç é˜…è¯»ç³»åˆ—ï¼Œä¸ªäººå­¦ä¹ è®°å½•ï¼Œä»…ä¾›å‚è€ƒã€‚<br />
ä»£ç ä»“åº“<a href="https://gitee.com/cndaqiang/QE-6.4.1/tree/master">QE-6.4.1@cndaqiang</a><br /></p>

<h2 id="å‚è€ƒ">å‚è€ƒ</h2>
<p><a href="https://www.quantum-espresso.org/pseudopotentials/unified-pseudopotential-format">QE-UNIFIED PSEUDOPOTENTIAL FORMAT</a><br />
<a href="https://github.com/QEF/q-e.git">q-e code</a><br /></p>

<h2 id="æ³¨">æ³¨</h2>
<ul>
  <li>æœ¬æ–‡ç›®å‰ä»…è®°å½•v2çš„UPFèµåŠ¿è¯»å…¥è¿‡ç¨‹</li>
  <li>ä½¿ç”¨çš„èµåŠ¿ä¸»è¦æ‘¸å®ˆæ’èµåŠ¿<a href="https://github.com/pipidog/ONCVPSP">ONCVPSP</a></li>
</ul>

<h2 id="å…¬å¼">å…¬å¼</h2>
<p>ä¸­å¿ƒç«‹åœºçš„æ³¢å‡½æ•°å…·æœ‰ $ \psi (\overrightarrow{r}) = R(r)Y_{lm} $ çš„å½¢å¼,<br />
å…¶ä¸­ $ Y_{lm} $ æ˜¯çƒè°å‡½æ•°ï¼Œå°†$ \psi $è¡¨è¾¾å¼å¸¦å…¥ä¸­å¿ƒç«‹åœºçš„è–›å®šè°”æ–¹ç¨‹ï¼Œå¾—åˆ°$ R(r) $æ»¡è¶³çš„æ–¹ç¨‹ï¼Œå…¶æ„Ÿå—çš„åŠ¿åœºä¸è§’åŠ¨é‡$ l,m $æœ‰å…³<br />
è€Œä¸”ï¼Œlç›¸åŒçš„æ€æ˜¯èƒ½é‡ç®€å¹¶æ€(å¯¹äº1/råº“ä¼¦å½¢å¼çš„åŠ¿åœºï¼Œç›¸åŒçš„nä¸åŒçš„lä¹Ÿæ˜¯èƒ½é‡ç®€å¹¶)<br />
åå‘æ¨å¯¼å¯å¾—å‡ºèµåŠ¿ä¸è§’åŠ¨é‡æœ‰å…³ï¼Œè¿›ä¸€æ­¥èµåŠ¿å¯ä»¥åˆ†ä¸ºå±€åŸŸéƒ¨åˆ†(å¾„å‘)å’Œéå±€åŸŸéƒ¨åˆ†(è§’å‘ç›¸å…³)</p>

<script type="math/tex; mode=display">V_{pp}(r)=V_{local}(r) + \delta V_{non-local}(r)</script>

<script type="math/tex; mode=display">% <![CDATA[
\delta V_{non-local}(r) = \sum_{lm} | Y_{lm} > V_{l}(r) < Y_{lm} | %]]></script>

<p>KBå¯åˆ†ç¦»èµåŠ¿</p>

<script type="math/tex; mode=display">% <![CDATA[
\delta V_{non-local}(r) = \sum_{lm}  \left [        \sum_{s,s^{,} }  B_{s,s^{,} }  | \beta_{s} >  < \beta_{s^{,}}     |  \right ] _{lm} %]]></script>

<p>å¯¹äºUSPP,å¦‚ä¸‹, <strong>åœ¨QEä¸­éƒ½ä½¿ç”¨USPPçš„æ–¹å¼è¯»å…¥USPP/NC/ç­‰èµåŠ¿</strong>
<br />å±€åŸŸ<strong>PP_LOCAL</strong>
<br />éå±€åŸŸ:
<br /><strong>PP_NONLOCAL/PP_BETA</strong> $ | \beta_{s} &gt; $
<br /><strong>PP_NONLOCAL/PP_DIJ</strong> $ D_{s,s^{,} } $</p>

<script type="math/tex; mode=display">% <![CDATA[
\delta V_{NL}^{US}(r) =      \sum_{s,s^{,} }  D_{s,s^{,} }  | \beta_{s} >  < \beta_{s^{,}}     | %]]></script>

<h2 id="ç›¸å…³æ–‡ä»¶">ç›¸å…³æ–‡ä»¶</h2>
<h3 id="è¯»å…¥èµåŠ¿">è¯»å…¥èµåŠ¿</h3>
<ul>
  <li><code class="highlighter-rouge">Modules/read_pseudo.f90 -&gt; SUBROUTINE readpp</code> èµåŠ¿è¯»å–å…¥å£:è°ƒç”¨å„ç§å½¢å¼çš„èµåŠ¿</li>
  <li><code class="highlighter-rouge">Modules/upf.f90 -&gt; SUBROUTINE read_upf</code> UPFèµåŠ¿è¯»å–å…¥å£:è°ƒç”¨å„ä¸ªç‰ˆæœ¬çš„UPFèµåŠ¿</li>
  <li><code class="highlighter-rouge">Modules/read_upf_v2.f90 -&gt; SUBROUTINE read_upf_v2</code> Version 2 çš„UPFèµåŠ¿è¯»å–å…¥å£:è¯»å…¥Mesh,Local,Non-Local,Beta Fun, Wfcç­‰<br />
å…¶ä»–ç‰ˆæœ¬çš„UPFç•¥</li>
  <li><code class="highlighter-rouge">FoX/lib/*</code>,è¯»å–UPFæ ¼å¼ä½¿ç”¨Foxè¾…åŠ©è¯»å…¥,ç¼–è¯‘è‡ª<code class="highlighter-rouge">archive/fox.tgz</code></li>
</ul>

<h3 id="èµåŠ¿å®šä¹‰">èµåŠ¿å®šä¹‰</h3>
<ul>
  <li><code class="highlighter-rouge">Modules/uspp.f90 -&gt; TYPE (pseudo_upf),  ALLOCATABLE, TARGET :: upf(:)</code>èµåŠ¿å®šä¹‰<br />
<code class="highlighter-rouge">MODULE uspp</code>:USPPå’ŒNCPPçš„upfå‚æ•°æ¨¡å—</li>
  <li><code class="highlighter-rouge">Modules/pseudo_types.f90 -&gt; TYPE pseudo_upf</code>èµåŠ¿ç»“æ„ä½“å„ä¸ªå‚æ•°å®šä¹‰:Mesh,Local,Non-Local,Beta Fun, Wfc<br />
åæœŸä»£ç è°ƒç”¨èµåŠ¿å¯ä»¥ä»è¿™é‡Œæ‰¾æ³¨é‡Šï¼Œä¸‹é¢è¡¨æ ¼ä¸­æœ‰å…·ä½“è§£é‡Šå’Œè¾“å…¥ç¤ºä¾‹</li>
  <li><code class="highlighter-rouge">Modules/atom.f90 -&gt; type(radial_grid_type), allocatable, target :: rgrid(:)</code>èµåŠ¿å¾„å‘åæ ‡ç»“æ„ä½“å®šä¹‰<br />
<code class="highlighter-rouge">upf(nt)%grid =&gt; rgrid(nt)</code></li>
  <li><code class="highlighter-rouge">Modules/radial_grids.f90 -&gt; TYPE radial_grid_type</code> å¾„å‘åæ ‡ç»“æ„ä½“å„ä¸ªå‚æ•°å®šä¹‰
<code class="highlighter-rouge">r,rab,r^2...</code></li>
</ul>

<h2 id="èµåŠ¿ç»“æ„ä½“å®šä¹‰">èµåŠ¿ç»“æ„ä½“å®šä¹‰</h2>
<p>å‚è€ƒè‡ª<code class="highlighter-rouge">Modules/pseudo_types.f90</code><br />
ä¸‹é¢è¡¨æ ¼ä¸­æ¥æºåˆ—çš„:</p>
<ul>
  <li><strong>PP_HEADER</strong> æ¥è‡ªèµåŠ¿æ–‡ä»¶ä¸­çš„PP_HEADERèŠ‚ç‚¹çš„ä¿¡æ¯,ä»¥ä¸‹åŒç†</li>
  <li><strong>MESH</strong></li>
  <li><strong>PP_LOCAL</strong></li>
  <li><strong>PP_NONLOCAL</strong></li>
  <li><strong>PP_NLCC</strong></li>
  <li><strong>PP_PWSCF</strong></li>
  <li><strong>PP_SPIN_ORB</strong></li>
  <li><strong>PP_RHOATOM</strong></li>
</ul>

<h3 id="åŸºæœ¬ä¿¡æ¯">åŸºæœ¬ä¿¡æ¯</h3>

<table>
  <thead>
    <tr>
      <th>ç±»å‹</th>
      <th>å˜é‡å[=é»˜è®¤å€¼]</th>
      <th>å¤‡æ³¨</th>
      <th>æ¥æº</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>CHARACTER(LEN=80)</td>
      <td>generated=â€™ â€˜</td>
      <td>generator software</td>
      <td>PP_HEADER <br /> generated=â€Generated using ONCVPSP code by D. R. Hamannâ€</td>
    </tr>
    <tr>
      <td>CHARACTER(LEN=80)</td>
      <td>author=â€™anonymousâ€™</td>
      <td>pseudopotentialâ€™s author</td>
      <td>PP_HEADER <br />  author=â€anonymousâ€</td>
    </tr>
    <tr>
      <td>CHARACTER(LEN=80)</td>
      <td>date=â€™ â€˜</td>
      <td>generation date</td>
      <td>PP_HEADER <br /> date=â€170818â€</td>
    </tr>
    <tr>
      <td>CHARACTER(LEN=80)</td>
      <td>comment=â€™ â€˜</td>
      <td>authorâ€™s comment</td>
      <td>PP_HEADER <br /> comment=â€â€</td>
    </tr>
    <tr>
      <td>CHARACTER(LEN=2)</td>
      <td>psd=â€™ â€˜</td>
      <td>Element label</td>
      <td>PP_HEADER <br /> element=â€O â€œ</td>
    </tr>
    <tr>
      <td>CHARACTER(LEN=20)</td>
      <td>typ=â€™ â€˜</td>
      <td>Pseudo type ( NC or US or PAW)</td>
      <td>PP_HEADER <br /> pseudo_type=â€NCâ€</td>
    </tr>
    <tr>
      <td>CHARACTER(len=6)</td>
      <td>rel=â€™ â€˜</td>
      <td>relativistic:<code class="highlighter-rouge"> {no|scalar|full}</code></td>
      <td>PP_HEADER <br />  relativistic=â€fullâ€</td>
    </tr>
    <tr>
      <td>LOGICAL</td>
      <td>tvanp</td>
      <td>.true. if Ultrasoft</td>
      <td>PP_HEADER <br />  is_ultrasoft=â€Fâ€</td>
    </tr>
    <tr>
      <td>LOGICAL</td>
      <td>tcoulombp</td>
      <td>.true. if Coulomb 1/r potential</td>
      <td>PP_HEADER <br />  is_coulomb=â€Fâ€</td>
    </tr>
    <tr>
      <td>LOGICAL</td>
      <td>nlcc</td>
      <td>Non linear core corrections</td>
      <td>PP_HEADER <br />  core_correction=â€Tâ€</td>
    </tr>
    <tr>
      <td>LOGICAL</td>
      <td>is_gth</td>
      <td>.true. if Goedecker-Teter-Hutter</td>
      <td>v2UPFæ˜¯False</td>
    </tr>
    <tr>
      <td>LOGICAL</td>
      <td>is_multiproj</td>
      <td>.true. if multiple projectors per l <br /> (for NC PP only; US-PP and PAW are assumed to be multi-projector)</td>
      <td>v2UPFæ˜¯.True.</td>
    </tr>
    <tr>
      <td>CHARACTER(LEN=25)</td>
      <td>dft</td>
      <td>Exch-Corr type</td>
      <td>PP_HEADER <br />   functional=â€PBEâ€</td>
    </tr>
    <tr>
      <td>REAL(DP)</td>
      <td>zp</td>
      <td>z valence</td>
      <td>PP_HEADER <br />  z_valence=â€    6.00â€</td>
    </tr>
    <tr>
      <td>REAL(DP)</td>
      <td>etotps</td>
      <td>total energy</td>
      <td>PP_HEADER <br />  total_psenergy=â€  -3.15123440404E+01â€</td>
    </tr>
    <tr>
      <td>REAL(DP)</td>
      <td>ecutwfc</td>
      <td>suggested cut-off for wfc</td>
      <td>PP_HEADER <br />  wfc_cutoff=â€?â€, oncvæ²¡æä¾›</td>
    </tr>
    <tr>
      <td>REAL(DP)</td>
      <td>ecutrho</td>
      <td>suggested cut-off for rho</td>
      <td>PP_HEADER <br />   rho_cutoff=â€   9.35000000000E+00â€</td>
    </tr>
    <tr>
      <td>CHARACTER(len=11)</td>
      <td>nv</td>
      <td>UPF file three-digit version i.e. 2.0.0</td>
      <td>PP_HEADER <br />  <code class="highlighter-rouge">&lt;UPF version="2.0.1"&gt;</code></td>
    </tr>
    <tr>
      <td>INTEGER</td>
      <td>lmax</td>
      <td>maximum l component in beta</td>
      <td>PP_HEADER <br />  l_max=â€2â€</td>
    </tr>
    <tr>
      <td>INTEGER</td>
      <td>lmax_rho</td>
      <td>max l component in charge (should be <code class="highlighter-rouge">2*lmax</code>)</td>
      <td>PP_HEADER <br />  l_max_rho = â€œ?â€</td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>vnl(:,:,:)</td>
      <td><code class="highlighter-rouge">vnl(i,l,s) = V(r_i)_{ls}</code><br />(semilocal form) only for single-channel NC PP<br /></td>
      <td>Â </td>
    </tr>
  </tbody>
</table>

<h3 id="wavefunctions-and-projectors">Wavefunctions and projectors</h3>

<table>
  <thead>
    <tr>
      <th>ç±»å‹</th>
      <th>å˜é‡å[=é»˜è®¤å€¼]</th>
      <th>å¤‡æ³¨</th>
      <th>æ¥æº</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>INTEGER</td>
      <td>nwfc</td>
      <td>number of atomic wavefunctions</td>
      <td>PP_HEADER <br />   number_of_wfc=â€3â€</td>
    </tr>
    <tr>
      <td>INTEGER</td>
      <td>nbeta</td>
      <td>number of projectors</td>
      <td>PP_HEADER <br />   number_of_proj=â€8â€</td>
    </tr>
    <tr>
      <td>INTEGER,  POINTER</td>
      <td>kbeta(:)</td>
      <td>kbeta(nbeta) see below<br />kbeta&lt;=mesh is the number of grid points for each beta function<br />beta(r,nb) = 0 for r &gt; r(kbeta(nb))<br />betaå‡½æ•°çš„å¤§å°å’Œç½‘æ ¼ä¸€æ ·ï¼Œå¯¹äºå¤§äºkbetaçš„betaå‡½æ•°éƒ¨åˆ†éƒ½æ˜¯0ï¼Œä»èµåŠ¿æ–‡ä»¶ä¸­ä¹Ÿå¯ä»¥çœ‹åˆ°ä¸€å †0</td>
      <td>PP_NONLOCAL/PP_BETA å±æ€§<br /> cutoff_radius_index=â€ 152â€</td>
    </tr>
    <tr>
      <td>INTEGER</td>
      <td>kkbeta</td>
      <td>kkbeta=max(kbeta(:))<br />kkbeta&lt;=mesh is the largest of such number so that for all beta<br />beta(r,nb) = 0 for r &gt; r(kkbeta)</td>
      <td>Â </td>
    </tr>
    <tr>
      <td>INTEGER,  POINTER</td>
      <td>lll(:)</td>
      <td>lll(nbeta) l of each projector</td>
      <td>PP_NONLOCAL/PP_BETA å±æ€§<br /> angular_momentum=â€0â€   <br /> PP_SPIN_ORB/PP_RELBETA å±æ€§<br /> lll=â€0â€</td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>beta(:,:)</td>
      <td>beta(mesh,nbeta) projectors</td>
      <td>PP_NONLOCAL/PP_BETA æ•°æ®</td>
    </tr>
    <tr>
      <td>CHARACTER(LEN=2), POINTER</td>
      <td>els(:)</td>
      <td>els(nwfc) label of wfc</td>
      <td>PP_PWSCF/PP_CHI å±æ€§ <br /> label=â€2Sâ€</td>
    </tr>
    <tr>
      <td>CHARACTER(LEN=2), POINTER</td>
      <td>els_beta(:)=â€Xnâ€</td>
      <td>els(nbeta) label of beta</td>
      <td>PP_NONLOCAL/PP_BETA å±æ€§<br />  label=â€?â€</td>
    </tr>
    <tr>
      <td>INTEGER, POINTER</td>
      <td>nchi(:)</td>
      <td>lchi(nwfc) value of pseudo-n for wavefcts</td>
      <td>PP_PWSCF/PP_CHI å±æ€§ <br />   n=â€?â€</td>
    </tr>
    <tr>
      <td>INTEGER, POINTER</td>
      <td>lchi(:)</td>
      <td>lchi(nwfc) value of l for wavefcts</td>
      <td>PP_PWSCF/PP_CHI å±æ€§ <br />  l=â€0â€</td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>oc(:)</td>
      <td>oc(nwfc) occupancies for wavefcts</td>
      <td>PP_PWSCF/PP_CHI å±æ€§ <br />   occupation=â€ 2.000â€</td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>epseu(:)</td>
      <td>pseudo one-particle energy (nwfc)</td>
      <td>PP_PWSCF/PP_CHI å±æ€§ <br />  pseudo_energy=â€   -0.1761094801E+01â€</td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>rcut_chi(:)</td>
      <td>rcut_chi(nwfc) cutoff inner radius</td>
      <td>PP_PWSCF/PP_CHI å±æ€§ <br /> cutoff_radius=â€?â€</td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>rcutus_chi(:)</td>
      <td>rcutus_chi(nwfc) ultrasoft outer radius</td>
      <td>PP_PWSCF/PP_CHI å±æ€§ <br />  ultrasoft_cutoff_radius=â€?â€</td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>chi(:,:)</td>
      <td>chi(mesh,nwfc) atomic wavefcts<br />Chi and rho_at are only used for initial density and initial wfcs:</td>
      <td>PP_PWSCF/PP_CHI å€¼</td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>rho_at(:)</td>
      <td>rho_at(mesh) atomic charge<br />Chi and rho_at are only used for initial density and initial wfcs:</td>
      <td>PP_RHOATOM å€¼</td>
    </tr>
  </tbody>
</table>

<h3 id="minimal-radial-grid">Minimal radial grid:</h3>

<table>
  <thead>
    <tr>
      <th>ç±»å‹</th>
      <th>å˜é‡å[=é»˜è®¤å€¼]</th>
      <th>å¤‡æ³¨</th>
      <th>æ¥æº</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>INTEGER</td>
      <td>mesh</td>
      <td>number of points in the radial mesh</td>
      <td>PP_HEADER <br />  mesh_size=â€   936â€</td>
    </tr>
    <tr>
      <td>REAL(DP)</td>
      <td>xmin</td>
      <td>the minimum x of the linear mesh</td>
      <td>MESHå±æ€§</td>
    </tr>
    <tr>
      <td>REAL(DP)</td>
      <td>rmax</td>
      <td>the maximum radius of the mesh</td>
      <td>MESHå±æ€§</td>
    </tr>
    <tr>
      <td>REAL(DP)</td>
      <td>zmesh</td>
      <td>the nuclear charge used for mesh</td>
      <td>MESHå±æ€§</td>
    </tr>
    <tr>
      <td>REAL(DP)</td>
      <td>dx</td>
      <td>the deltax of the linear mesh</td>
      <td>MESHå±æ€§</td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>r(:)</td>
      <td>r(mesh)  radial grid</td>
      <td>upf%r(1:upf%mesh) = PP_MESH/PP_R</td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>rab(:)</td>
      <td>rab(mesh) dr(x)/dx (x=linear grid)</td>
      <td>upf%rab(1:upf%mesh) = PP_MESH/PP_RAB</td>
    </tr>
  </tbody>
</table>

<h3 id="pseudized-core-charge">Pseudized core charge</h3>

<table>
  <thead>
    <tr>
      <th>ç±»å‹</th>
      <th>å˜é‡å[=é»˜è®¤å€¼]</th>
      <th>å¤‡æ³¨</th>
      <th>æ¥æº</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>rho_atc(:)</td>
      <td>rho_atc(mesh) atomic core charge</td>
      <td>Â </td>
    </tr>
  </tbody>
</table>

<h3 id="local-potential">Local potential</h3>

<table>
  <thead>
    <tr>
      <th>ç±»å‹</th>
      <th>å˜é‡å[=é»˜è®¤å€¼]</th>
      <th>å¤‡æ³¨</th>
      <th>æ¥æº</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>INTEGER</td>
      <td>lloc</td>
      <td>L of channel used to generate local potential<br />(if &lt; 0 it was generated by smoothing AE potential)</td>
      <td>PP_HEADER <br />   l_local=â€-1â€</td>
    </tr>
    <tr>
      <td>REAL(DP)</td>
      <td>rcloc</td>
      <td>vloc = v_ae for r &gt; rcloc</td>
      <td>Â </td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>vloc(:)</td>
      <td>vloc(mesh) local atomic potential</td>
      <td>PP_LOCALå€¼</td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>dion(:,:)</td>
      <td>dion(nbeta,nbeta) atomic D_{mu,nu}</td>
      <td>PP_NONLOCAL/PP_DIJ å€¼</td>
    </tr>
  </tbody>
</table>

<h3 id="augmentation">Augmentation</h3>

<table>
  <thead>
    <tr>
      <th>ç±»å‹</th>
      <th>å˜é‡å[=é»˜è®¤å€¼]</th>
      <th>å¤‡æ³¨</th>
      <th>æ¥æº</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>LOGICAL</td>
      <td>q_with_l</td>
      <td>if .true. qfunc is pseudized in different ways for different</td>
      <td>Â </td>
    </tr>
    <tr>
      <td>INTEGER</td>
      <td>nqf</td>
      <td>number of Q coefficients</td>
      <td>Â </td>
    </tr>
    <tr>
      <td>INTEGER</td>
      <td>nqlc</td>
      <td>number of angular momenta in Q</td>
      <td>Â </td>
    </tr>
    <tr>
      <td>REAL(DP)</td>
      <td>qqq_eps</td>
      <td>qfunc is null if its norm is .lt. qqq_eps</td>
      <td>éus and é paw qqq_eps=-1._dp</td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>rinner(:)</td>
      <td><code class="highlighter-rouge">rinner(0:2*lmax)</code> r_L</td>
      <td>Â </td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>qqq(:,:)</td>
      <td>qqq(nbeta,nbeta)  q_{mu,nu}</td>
      <td>Â </td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>qfunc(:,:)</td>
      <td><code class="highlighter-rouge">qfunc(mesh,nbeta*(nbeta+1)/2)</code><br />Augmentation without L dependecy<br /> <code class="highlighter-rouge">Q_{mu,nu}(|r|) function for |r|&gt; r_L</code></td>
      <td>Â </td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>qfuncl(:,:,:)</td>
      <td><code class="highlighter-rouge">qfuncl(mesh,nbeta*(nbeta+1)/2,l)</code><br />Augmentation depending on L (optional, compulsory for PAW)<br /><code class="highlighter-rouge">Q_{mu,nu}(|r|) function for |r|&gt; r_L</code></td>
      <td>Â </td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>qfcoef(:,:,:,:)</td>
      <td><code class="highlighter-rouge">qfcoef(nqf,0:2*lmax,nbeta,nbeta)</code><br />Analitycal coeffs cor small r expansion of qfunc (Vanderbiltâ€™s code) <br /> <code class="highlighter-rouge">coefficients for Q for |r|&lt;r_L</code></td>
      <td>Â </td>
    </tr>
  </tbody>
</table>

<h3 id="wfc">wfc</h3>
<p>All electron and pseudo wavefunction, pswfc differ from chi as they are   one for each beta, not just some choosen for initial conditions</p>

<table>
  <thead>
    <tr>
      <th>ç±»å‹</th>
      <th>å˜é‡å[=é»˜è®¤å€¼]</th>
      <th>å¤‡æ³¨</th>
      <th>æ¥æº</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>LOGICAL</td>
      <td>has_wfc</td>
      <td>if true, UPF contain AE and PS wfc for each beta</td>
      <td>PP_HEADER <br />  has_wfc=â€Fâ€</td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>aewfc(:,:)</td>
      <td>wfc(mesh,nbeta) all-electron wfc</td>
      <td>Â </td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>pswfc(:,:)</td>
      <td>wfc(mesh,nbeta) pseudo wfc</td>
      <td>Â </td>
    </tr>
  </tbody>
</table>

<h3 id="soc">SOC</h3>

<table>
  <thead>
    <tr>
      <th>ç±»å‹</th>
      <th>å˜é‡å[=é»˜è®¤å€¼]</th>
      <th>å¤‡æ³¨</th>
      <th>æ¥æº</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>LOGICAL</td>
      <td>has_so</td>
      <td>if .true. includes spin-orbit</td>
      <td>PP_HEADER <br />  has_so=â€Tâ€</td>
    </tr>
    <tr>
      <td>INTEGER, POINTER</td>
      <td>nn(:)</td>
      <td>nn(nwfc) quantum number of wfc</td>
      <td>PP_SPIN_ORB/PP_RELWFC å±æ€§<br /> nn=â€1â€</td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>rcut(:)</td>
      <td>cut-off radius(nbeta)</td>
      <td>PP_NONLOCAL/PP_BETA å±æ€§<br />  cutoff_radius=â€    1.5100000000E+00â€</td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>rcutus(:)</td>
      <td>ultrasoft cut-off radius (nbeta)</td>
      <td>PP_NONLOCAL/PP_BETA å±æ€§<br />  norm_conserving_radius=â€?â€</td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>jchi(:)</td>
      <td>jchi(nwfc) j=l+1/2 or l-1/2 of wfc</td>
      <td>PP_SPIN_ORB/PP_RELWFC å±æ€§<br />  jchi=â€0.5â€</td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>jjj(:)</td>
      <td>jjj(nbeta) j=l+1/2 or l-1/2 of beta</td>
      <td>PP_SPIN_ORB/PP_RELBETA å±æ€§<br /> jjj=â€0.5â€</td>
    </tr>
  </tbody>
</table>

<h3 id="paw">PAW:</h3>

<table>
  <thead>
    <tr>
      <th>ç±»å‹</th>
      <th>å˜é‡å[=é»˜è®¤å€¼]</th>
      <th>å¤‡æ³¨</th>
      <th>æ¥æº</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>INTEGER</td>
      <td>paw_data_format</td>
      <td>The version of the format</td>
      <td>Â </td>
    </tr>
    <tr>
      <td>LOGICAL</td>
      <td>tpawp</td>
      <td>true if atom is PAW, PAW data must be present</td>
      <td>PP_HEADER <br />   is_paw=â€Fâ€</td>
    </tr>
    <tr>
      <td>TYPE(paw_in_upf)</td>
      <td>paw</td>
      <td>additional data for PAW (see above)</td>
      <td>Â </td>
    </tr>
    <tr>
      <td>TYPE(radial_grid_type),POINTER</td>
      <td>grid</td>
      <td>pointer to the corresponding grid in radial_grids module</td>
      <td>Â </td>
    </tr>
  </tbody>
</table>

<h3 id="gipaw">GIPAW:</h3>

<table>
  <thead>
    <tr>
      <th>ç±»å‹</th>
      <th>å˜é‡å[=é»˜è®¤å€¼]</th>
      <th>å¤‡æ³¨</th>
      <th>æ¥æº</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>LOGICAL</td>
      <td>has_gipaw</td>
      <td>Whether GIPAW data is included</td>
      <td>PP_HEADER <br />   has_gipaw=â€Fâ€</td>
    </tr>
    <tr>
      <td>LOGICAL</td>
      <td>paw_as_gipaw        !EMINE</td>
      <td>Â </td>
      <td>PP_HEADER <br />  paw_as_gipaw=â€?â€</td>
    </tr>
    <tr>
      <td>INTEGER</td>
      <td>gipaw_data_format</td>
      <td>The version of the format</td>
      <td>Â </td>
    </tr>
    <tr>
      <td>INTEGER</td>
      <td>gipaw_ncore_orbitals</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>gipaw_core_orbital_n(:)</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>gipaw_core_orbital_l(:)</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>CHARACTER(LEN=2), POINTER</td>
      <td>gipaw_core_orbital_el(:)</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>gipaw_core_orbital(:,:)</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>gipaw_vlocal_ae(:)</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>gipaw_vlocal_ps(:)</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>INTEGER</td>
      <td>gipaw_wfs_nchannels</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>CHARACTER(LEN=2), POINTER</td>
      <td>gipaw_wfs_el(:)</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>INTEGER, POINTER</td>
      <td>gipaw_wfs_ll(:)</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>gipaw_wfs_ae(:,:)</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>gipaw_wfs_rcut(:)</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>gipaw_wfs_rcutus(:)</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>REAL(DP), POINTER</td>
      <td>gipaw_wfs_ps(:,:)</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
  </tbody>
</table>

<h3 id="md5">MD5</h3>

<table>
  <thead>
    <tr>
      <th>ç±»å‹</th>
      <th>å˜é‡å[=é»˜è®¤å€¼]</th>
      <th>å¤‡æ³¨</th>
      <th>æ¥æº</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>CHARACTER(len=32)</td>
      <td>MD5_cksum = â€˜NOT SETâ€™</td>
      <td>MD5 checksum â€¦ used to verify integrity of the information contained<br />in the pseudopotential file w.r.t previous run</td>
      <td>Â </td>
    </tr>
  </tbody>
</table>

<h2 id="å…¶ä»–éœ€è¦çš„ç»“æ„ä½“">å…¶ä»–éœ€è¦çš„ç»“æ„ä½“</h2>
<h3 id="radial_grid_type-ç»“æ„ä½“ä¿¡æ¯">radial_grid_type ç»“æ„ä½“ä¿¡æ¯</h3>
<p>å‚è€ƒè‡ª<code class="highlighter-rouge">Modules/radial_grids.f90</code></p>

<div class="language-fortran highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">TYPE</span><span class="w"> </span><span class="n">radial_grid_type</span><span class="w">

  </span><span class="kt">INTEGER</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="p">&amp;</span><span class="w">
       </span><span class="n">mesh</span><span class="w">          </span><span class="c1">! the actual number of mesh points</span><span class="w">
  </span><span class="kt">REAL</span><span class="p">(</span><span class="n">DP</span><span class="p">),</span><span class="k">POINTER</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="p">&amp;</span><span class="w">
       </span><span class="n">r</span><span class="p">(:),</span><span class="w">    </span><span class="p">&amp;</span><span class="w"> </span><span class="c1">! the radial mesh</span><span class="w">
       </span><span class="n">r2</span><span class="p">(:),</span><span class="w">   </span><span class="p">&amp;</span><span class="w"> </span><span class="c1">! the square of the radial mesh</span><span class="w">
       </span><span class="n">rab</span><span class="p">(:),</span><span class="w">  </span><span class="p">&amp;</span><span class="w"> </span><span class="c1">! d r(x) / d x where x is the linear gridã€€ï¼ç›¸é‚»ç½‘æ ¼0-&gt;--&gt;A-&gt;B-&gt;--&gt;Nçš„å·®R(B)-R(A)</span><span class="w">
       </span><span class="n">sqr</span><span class="p">(:),</span><span class="w">  </span><span class="p">&amp;</span><span class="w"> </span><span class="c1">! the square root of the radial mesh</span><span class="w">
       </span><span class="n">rm1</span><span class="p">(:),</span><span class="w">  </span><span class="p">&amp;</span><span class="w"> </span><span class="c1">! 1 / r</span><span class="w">
       </span><span class="n">rm2</span><span class="p">(:),</span><span class="w">  </span><span class="p">&amp;</span><span class="w"> </span><span class="c1">! 1 / r**2</span><span class="w">
       </span><span class="n">rm3</span><span class="p">(:)</span><span class="w">     </span><span class="c1">! 1 / r**3</span><span class="w">
  </span><span class="kt">REAL</span><span class="p">(</span><span class="n">DP</span><span class="p">)</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="p">&amp;</span><span class="w">
       </span><span class="n">xmin</span><span class="p">,</span><span class="w">       </span><span class="p">&amp;</span><span class="w"> </span><span class="c1">! the minimum x</span><span class="w">
       </span><span class="n">rmax</span><span class="p">,</span><span class="w">       </span><span class="p">&amp;</span><span class="w"> </span><span class="c1">! the maximum radial point</span><span class="w">
       </span><span class="n">zmesh</span><span class="p">,</span><span class="w">      </span><span class="p">&amp;</span><span class="w"> </span><span class="c1">! the ionic charge used for the mesh</span><span class="w">
       </span><span class="n">dx</span><span class="w">            </span><span class="c1">! the deltax of the linear mesh</span><span class="w">
</span><span class="k">END</span><span class="w"> </span><span class="k">TYPE</span><span class="w"> </span><span class="n">radial_grid_type</span><span class="w">
</span></code></pre></div></div>

<h2 id="ç›¸å…³å˜é‡">ç›¸å…³å˜é‡</h2>
<h3 id="module-uspp_param"><code class="highlighter-rouge">MODULE uspp_param</code></h3>
<p>File:<code class="highlighter-rouge">Modules/uspp.f90</code><br /></p>
<blockquote>
  <p>Ultrasoft and Norm-Conserving pseudopotential parameters</p>
</blockquote>

<table>
  <thead>
    <tr>
      <th>å˜é‡</th>
      <th>å«ä¹‰</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">TYPE (pseudo_upf),  ALLOCATABLE, TARGET    upf(:)</code></td>
      <td>pseudo potential</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">INTEGER    nh(npsx),</code></td>
      <td>number of beta functions per atomic type</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">INTEGER    nhm,</code></td>
      <td>max number of different beta functions per atom</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">INTEGER    nbetam,</code></td>
      <td>max number of beta functions</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">INTEGER    iver(3,npsx)</code></td>
      <td>version of the atomic code</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">INTEGER    lmaxkb,</code></td>
      <td>max angular momentum</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">INTEGER    lmaxq</code></td>
      <td>max angular momentum + 1 for Q functions</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">INTEGER    nvb,</code></td>
      <td>number of species with Vanderbilt PPs (CPV)</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">INTEGER   ish(npsx)</code></td>
      <td>for each specie the index of the first beta  <br /> function: ish(1)=1, ish(i)=1+SUM(nh(1:i-1))</td>
    </tr>
  </tbody>
</table>

<h3 id="module-uspp"><code class="highlighter-rouge">MODULE uspp</code></h3>
<p>File:<code class="highlighter-rouge">Modules/uspp.f90</code><br /></p>
<blockquote>
  <p>Ultrasoft PPs:</p>
  <ul>
    <li>Clebsch-Gordan coefficients â€œapâ€, auxiliary variables â€œlpxâ€, â€œlplâ€</li>
    <li>beta and q functions of the solid</li>
  </ul>
</blockquote>

<ul>
  <li><code class="highlighter-rouge">dvan(:,:,:)  </code>      the D functions of the solid</li>
  <li><code class="highlighter-rouge">deeq(:,:,:,:)</code>      the integral of V_eff and Q_{nm}</li>
  <li><code class="highlighter-rouge">qq_nt(:,:,:) </code>      the integral of q functions in the solid (ONE PER NTYP) used to be the qq array</li>
  <li><code class="highlighter-rouge">qq_at(:,:,:)</code>       the integral of q functions in the solid (ONE PER ATOM !!!!)</li>
  <li><code class="highlighter-rouge">nhtoj(:,:)  </code>       correspondence n &lt;-&gt; total angular momentum</li>
</ul>

<h2 id="upfæ–‡ä»¶å†…å®¹">UPFæ–‡ä»¶å†…å®¹</h2>
<h3 id="oncvpspèµåŠ¿ç»“æ„"><a href="https://github.com/pipidog/ONCVPSP">ONCVPSP</a>èµåŠ¿ç»“æ„</h3>
<p>æ–‡ä»¶å</p>
<ul>
  <li>xx_ONCV_PBE_sr.upf =&gt; scalar relativistic (for non-spin-orbit calculations)</li>
  <li>xx_ONCV_PBE_fr.upf =&gt; fully relativistic (for spin-orbit calculatons)</li>
</ul>

<p>æ–‡ä»¶ç»“æ„:<br />
ä»¥<a href="/web/file/2020/O_ONCV_PBE_fr.upf">O_ONCV_PBE_fr.upf</a>ä¸ºä¾‹<br />
æˆªå›¾æ¥è‡ª ä»£ç ä»“åº“<a href="https://gitee.com/cndaqiang/QE-6.4.1/tree/master">QE-6.4.1@cndaqiang</a><br />
<img src="/uploads/2020/04/oncv.png" alt="" /></p>

<h2 id="è¯»å…¥æµç¨‹">è¯»å…¥æµç¨‹</h2>
<ol>
  <li><code class="highlighter-rouge">iosys(PW/src/input.f90 )</code></li>
  <li><code class="highlighter-rouge">readpp(Modules/read_pseudo.f90)</code></li>
  <li><code class="highlighter-rouge">readupf(Modules/upf.f90)</code></li>
  <li><code class="highlighter-rouge">read_upf_v2(Modules/read_upf_v2.f90)</code></li>
</ol>

<h3 id="readpp-èµåŠ¿è¯»å–å…¥å£">readpp èµåŠ¿è¯»å–å…¥å£</h3>
<p>File:<code class="highlighter-rouge">Modules/read_pseudo.f90</code><br /></p>
<h4 id="åŠŸèƒ½">åŠŸèƒ½</h4>
<ul>
  <li>æ ¹æ®å…ƒç´ æ•°<code class="highlighter-rouge">ntyp</code>åˆ†é…<code class="highlighter-rouge">upf(ntyp),grid(ntyp)</code>å†…å­˜</li>
  <li>åˆ¤æ–­å„ä¸ªå…ƒç´ çš„ä½ç½®, æ£€æŸ¥æ˜¯å¦å­˜åœ¨</li>
  <li>è°ƒç”¨UPFèµåŠ¿è¯»å–å…¥å£<code class="highlighter-rouge">read_upf</code>,å¾ªç¯ä¾æ¬¡è¯»å…¥å„ä¸ªå…ƒç´ </li>
  <li>ç­‰</li>
</ul>

<h4 id="å‚æ•°-readpp--input_dft-printout-ecutwfc_pp-ecutrho_pp-">å‚æ•°: <code class="highlighter-rouge">readpp ( input_dft, printout, ecutwfc_pp, ecutrho_pp )</code></h4>
<ul>
  <li><code class="highlighter-rouge">CHARACTER(len=*), INTENT(INOUT) :: input_dft</code><br />
PWè¾“å…¥å‚æ•°<code class="highlighter-rouge">input_dft=</code>,å³æ˜¯å¦æŒ‡å®šè®¡ç®—ä½¿ç”¨çš„Excæ³›å‡½,é»˜è®¤ä»èµåŠ¿ä¸­è¯»å–</li>
  <li><code class="highlighter-rouge">LOGICAL, OPTIONAL, INTENT(IN) :: printout</code><br />
,é¢å¤–å¤šå‘å±å¹•è¾“å‡ºä¸€äº›ä¿¡æ¯</li>
  <li><code class="highlighter-rouge">REAL(DP), OPTIONAL, INTENT(OUT) :: ecutwfc_pp, ecutrho_pp</code><br />
æ³¢å‡½æ•°æˆªæ–­èƒ½ï¼Œç”µè·æˆªæ–­èƒ½</li>
</ul>

<p>ç”¨æ³•: <code class="highlighter-rouge">USE read_pseudo_mod,       ONLY : readpp</code><br />
ç¤ºä¾‹: <code class="highlighter-rouge">CALL readpp ( input_dft, .FALSE., ecutwfc_pp, ecutrho_pp )</code><br /></p>

<h3 id="read_upf-upfèµåŠ¿è¯»å–å…¥å£">read_upf UPFèµåŠ¿è¯»å–å…¥å£</h3>
<p>File:<code class="highlighter-rouge">Modules/upf.f90</code></p>
<h4 id="åŠŸèƒ½-1">åŠŸèƒ½</h4>
<ul>
  <li>ä½¿ç”¨Foxåº“, æ‰“å¼€upfæ–‡ä»¶</li>
  <li>æ ¹æ®UPF Nodeçš„versionå±æ€§ï¼Œè°ƒç”¨ç›¸åº”ç‰ˆæœ¬çš„UPFè¯»å…¥å‡½æ•°,å¦‚:<br />
<code class="highlighter-rouge">&lt;UPF version="2.0.1"&gt;</code>è°ƒç”¨<code class="highlighter-rouge">read_upf_v2</code></li>
</ul>

<h4 id="å‚æ•°-read_upfupf-grid-ierr-unit--filename">å‚æ•°: <code class="highlighter-rouge">read_upf(upf, grid, ierr, unit,  filename)</code></h4>
<ul>
  <li><code class="highlighter-rouge">INTEGER,INTENT(IN), OPTIONAL  :: unit</code>
<br /> Â  i/o unit</li>
  <li><code class="highlighter-rouge">CHARACTER(len=*),INTENT(IN),OPTIONAL :: filename</code>
<br /> Â  i/o filename</li>
  <li><code class="highlighter-rouge">TYPE(pseudo_upf),INTENT(INOUT) :: upf</code>
<br /> Â  upfå˜é‡, the derived type storing the pseudo data</li>
  <li><code class="highlighter-rouge">TYPE(radial_grid_type),OPTIONAL,INTENT(INOUT),TARGET :: grid</code>
<br /> Â  derived type where is possible to store data on the radial mesh</li>
  <li><code class="highlighter-rouge">INTEGER,INTENT(INOUT) :: ierr</code>
<br />é”™è¯¯ä»£ç 
 <br /> Â  On input:
 <br /> Â  ierr =0:   return if not a valid xml schema or UPF v.2 file
 <br /> Â  ierr/=0: continue if not a valid xml schema or UPF v.2 file
 <br /> Â  On output:
 <br /> Â  ierr=0: xml schema, ierr=-1: UPF v.1,  ierr=-2: UPF v.2
 <br /> Â  ierr&gt;0: error reading PP file
 <br /> Â  ierr=-81: error reading PP file, possibly UPF fix needed</li>
</ul>

<p>ç”¨æ³•:<code class="highlighter-rouge">USE upf_module,   ONLY: read_upf</code><br />
ç¤ºä¾‹:<code class="highlighter-rouge">CALL  read_upf(upf(nt), rgrid(nt), isupf, filename = file_pseudo )</code></p>

<h3 id="read_upf_v2-ç›´æ¥è¯»å…¥v2ç‰ˆupfæ–‡ä»¶å¹¶è®¾ç½®å‚æ•°">read_upf_v2 ç›´æ¥è¯»å…¥v2ç‰ˆUPFæ–‡ä»¶,å¹¶è®¾ç½®å‚æ•°</h3>
<p>File:<code class="highlighter-rouge">Modules/read_upf_v2.f90</code></p>
<h4 id="åŠŸèƒ½-2">åŠŸèƒ½</h4>
<ul>
  <li>è¯»å…¥<strong>PP_HEADER</strong>èŠ‚ç‚¹,è®¾ç½®å‚æ•°:<code class="highlighter-rouge">CALL read_upf_header(u, upf)</code></li>
  <li>è¯»å…¥<strong>PP_MESH</strong>èŠ‚ç‚¹,è®¾ç½®grifç­‰å‚æ•°:<code class="highlighter-rouge">CALL read_upf_mesh(u, upf, grid)</code></li>
  <li>è¯»å…¥<strong>PP_NLCC</strong>èŠ‚ç‚¹:<code class="highlighter-rouge">CALL extractDataContent(auxNode, upf%rho_atc)</code></li>
  <li>è¯»å…¥<strong>PP_LOCAL</strong>èŠ‚ç‚¹:<code class="highlighter-rouge">CALL extractDataContent(auxNode, upf%vloc)</code></li>
  <li>è¯»å…¥<strong>PP_NONLOCAL</strong>èŠ‚ç‚¹:<code class="highlighter-rouge">CALL read_upf_nonlocal(u, upf)</code></li>
  <li>è¯»å…¥<strong>PP_PSWFC/PP_CHI</strong>èŠ‚ç‚¹:<code class="highlighter-rouge">CALL read_upf_pswfc(u, upf)</code></li>
  <li>è¯»å…¥<strong>PP_FULL_WFC</strong>èŠ‚ç‚¹:<code class="highlighter-rouge">CALL read_upf_full_wfc(u, upf)</code>,ONCVèµåŠ¿ä¸­æ²¡æœ‰æ­¤é¡¹</li>
  <li>è¯»å…¥<strong>PP_RHOATOM</strong>èŠ‚ç‚¹:<code class="highlighter-rouge">CALL extractDataContent(auxNode, upf%rho_at)</code></li>
  <li>è¯»å…¥<strong>PP_SPIN_ORB</strong>èŠ‚ç‚¹:<code class="highlighter-rouge">CALL read_upf_spin_orb(u, upf)</code>,SOCå¯é€‰</li>
  <li>è¯»å…¥<strong>PP_PAW</strong>èŠ‚ç‚¹:<code class="highlighter-rouge">CALL read_upf_paw(u, upf)</code>,ONCVèµåŠ¿ä¸­æ²¡æœ‰æ­¤é¡¹</li>
  <li>è¯»å…¥<strong>PP_GIPAW</strong>èŠ‚ç‚¹:<code class="highlighter-rouge">CALL read_upf_gipaw(u, upf)</code>,ONCVèµåŠ¿ä¸­æ²¡æœ‰æ­¤é¡¹</li>
</ul>

<h4 id="å‚æ•°-read_upf_v2u-upf-grid-ierr-">å‚æ•°: <code class="highlighter-rouge">read_upf_v2(u, upf, grid, ierr) </code></h4>
<ul>
  <li>u èµåŠ¿æ–‡ä»¶èŠ‚ç‚¹å˜é‡</li>
  <li>upf åŒä¸ŠèµåŠ¿å˜é‡</li>
  <li>grid åŒä¸Šç½‘æ ¼</li>
  <li>ierr é”™è¯¯ä»£ç </li>
</ul>

<p>ç”¨æ³•:<code class="highlighter-rouge">USE read_upf_v2_module,ONLY: read_upf_v2</code>
ç¤ºä¾‹:<code class="highlighter-rouge">CALL read_upf_v2( u, upf, grid, ierr )</code></p>
:ET